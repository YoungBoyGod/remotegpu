# 物理机和容器访问架构说明

## 概述

RemoteGPU平台的访问管理架构设计为**通用架构**,可以同时支持物理机和容器两种不同的访问场景。本文档详细说明两种场景的区别、共同点以及实现方案。

## 1. 两种访问场景

### 1.1 场景一: 算力市场 - 物理机/裸金属服务器

#### 1.1.1 场景描述

**适用页面**: `frontend/src/views/ComputingMarketView.vue`

**资源类型**: 物理GPU服务器(裸金属服务器)

**典型配置**:
- GPU: RTX 5090 x2, RTX 4090 x2, vGPU-48GB等
- CPU: 16核-32核
- 内存: 64GB-128GB
- 硬盘: 4TB-7TB

**使用场景**:
- 客户租用整台物理服务器
- 需要完整的硬件资源和root权限
- 适合大规模深度学习训练任务
- 长期租用(按月计费)

**访问特点**:
- 直接SSH登录到物理机操作系统
- 拥有完整的系统权限
- 可以安装任意软件和驱动
- 性能最优,无虚拟化开销

#### 1.1.2 示例数据

```typescript
{
  id: 1,
  name: '北京B区-598机',
  region: '北京B区',
  gpuModel: 'RTX 5090',
  gpuMemory: 32,
  cpu: '16核',
  memory: 90,
  disk: 5881,
  status: 'available',
  loginInfo: {
    host: '6hiflzwte2xnkroq.ssh.x-gpu.com',
    ip: '192.168.1.101',  // 物理机的实际IP地址
    port: 56376,
    username: 'root',
    password: 'kD2oTIydfOKmQadjma0gH5JyDApG0uWn'
  }
}
```

### 1.2 场景二: 环境管理 - Docker容器

#### 1.2.1 场景描述

**适用页面**: `frontend/src/views/EnvironmentListView.vue`

**资源类型**: Docker容器(运行在物理机上)

**典型配置**:
- GPU: 按需分配(1-8卡)
- CPU: 按需分配(2-16核)
- 内存: 按需分配(8-64GB)
- 存储: 共享存储或独立卷

**使用场景**:
- 用户创建的训练环境
- 快速启动和销毁
- 资源灵活分配
- 适合开发、调试、小规模训练
- 按小时计费

**访问特点**:
- SSH登录到容器内部
- 容器内有限的权限
- 预装深度学习框架和工具
- 可以快速切换不同的镜像

#### 1.2.2 示例数据

```typescript
{
  id: 'abc123def456',
  name: '我的训练环境',
  image: 'pytorch:2.0-cuda11.8',
  gpuCount: 2,
  cpuCores: 8,
  memory: 32,
  status: 'running',
  loginInfo: {
    host: 'abc123def456.ssh.x-gpu.com',
    ip: '172.17.0.50',  // 容器的IP地址
    port: 52847,
    username: 'root',
    password: 'Pq9xLm3nVb8cWdRt2fYhGj5kZa1sXe4u'
  }
}
```

## 2. 技术实现的统一性

### 2.1 访问流程完全相同

从用户访问的角度,物理机和容器的访问流程是**完全相同的**:

```
┌─────────────────────────────────────────────────────────────┐
│ 用户访问: ssh root@6hiflzwte2xnkroq.ssh.x-gpu.com -p 56376 │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│ DNS解析: *.ssh.x-gpu.com → SSH网关IP (192.168.10.100)      │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│ SSH网关: 解析域名前缀,提取环境ID "6hiflzwte2xnkroq"        │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│ Redis查询: GET env:6hiflzwte2xnkroq:ip                      │
│ 返回: "192.168.1.101" (物理机) 或 "172.17.0.50" (容器)      │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│ SSH代理: 转发连接到目标IP:22端口                            │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│ 目标主机: 物理机或容器接收SSH连接                           │
└─────────────────────────────────────────────────────────────┘
```

### 2.2 网关层无需区分

**Nginx/OpenResty配置** (容器应用访问):

```nginx
server {
    listen 443 ssl http2;
    server_name ~^(?<env_id>[a-z0-9]+)-(?<port>\d+)\.container\.x-gpu\.com$;

    ssl_certificate /etc/ssl/wildcard.container.x-gpu.com.crt;
    ssl_certificate_key /etc/ssl/wildcard.container.x-gpu.com.key;

    location / {
        set $target_ip '';
        access_by_lua_block {
            local redis = require "resty.redis"
            local red = redis:new()
            red:connect("127.0.0.1", 6379)

            local env_id = ngx.var.env_id
            -- 查询目标IP,可能是物理机IP或容器IP
            local target_ip = red:get("env:" .. env_id .. ":ip")
            ngx.var.target_ip = target_ip
        }

        # 反向代理到目标IP,无需关心是物理机还是容器
        proxy_pass http://$target_ip:$port;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
    }
}
```

**关键点**: 网关层只需要知道目标IP,不需要区分是物理机还是容器。

### 2.3 Redis数据结构统一

```redis
# 物理机示例
SET env:6hiflzwte2xnkroq:ip "192.168.1.101"
SET env:6hiflzwte2xnkroq:ssh_port "56376"
SET env:6hiflzwte2xnkroq:type "physical"

# 容器示例
SET env:abc123def456:ip "172.17.0.50"
SET env:abc123def456:ssh_port "52847"
SET env:abc123def456:type "container"
```

**说明**:
- 键格式完全相同
- 只是IP地址不同(物理机IP vs 容器IP)
- 可选的type字段用于业务层区分,网关层不需要

## 3. 后端实现的区别

虽然网关层是统一的,但在**业务系统后端**需要区分两种场景。

### 3.1 数据模型区分

#### 3.1.1 Environment表结构

```go
type Environment struct {
    ID            string    `gorm:"primaryKey;size:16" json:"id"`
    Name          string    `gorm:"size:100;not null" json:"name"`
    Type          string    `gorm:"size:20;not null" json:"type"`  // "physical" 或 "container"

    // 访问信息(两种类型都需要)
    SSHHost       string    `gorm:"size:100;not null" json:"ssh_host"`
    SSHPort       int       `gorm:"not null" json:"ssh_port"`
    SSHUsername   string    `gorm:"size:50;not null" json:"ssh_username"`
    SSHPassword   string    `gorm:"size:100;not null" json:"ssh_password"`
    TargetIP      string    `gorm:"size:50;not null" json:"target_ip"`  // 物理机IP或容器IP

    // 物理机特有字段
    PhysicalMachineID *uint  `gorm:"index" json:"physical_machine_id,omitempty"`

    // 容器特有字段
    ContainerID       *string `gorm:"size:64" json:"container_id,omitempty"`
    ImageID           *uint   `gorm:"index" json:"image_id,omitempty"`

    // 公共字段
    UserID        uint      `gorm:"not null" json:"user_id"`
    Status        string    `gorm:"size:20;not null" json:"status"`
    CreatedAt     time.Time `json:"created_at"`
    UpdatedAt     time.Time `json:"updated_at"`
}
```

### 3.2 创建流程的区别

#### 3.2.1 物理机分配流程

```go
// 算力市场 - 分配物理机
func (s *ComputingMarketService) AllocateMachine(ctx context.Context, req *AllocateMachineRequest) (*Environment, error) {
    // 1. 查询可用的物理机
    machine, err := s.machineDAO.GetAvailableMachine(ctx, req.MachineID)
    if err != nil {
        return nil, err
    }

    // 2. 生成环境标识符
    envID := utils.GenerateEnvironmentID()

    // 3. 生成访问信息
    accessInfo := service.GenerateAccessInfo(envID, machine.IP)  // 使用物理机IP

    // 4. 存储到Redis
    if err := cache.SetEnvironmentMapping(ctx, envID, accessInfo); err != nil {
        return nil, err
    }

    // 5. 创建环境记录
    environment := &entity.Environment{
        ID:                envID,
        Name:              machine.Name,
        Type:              "physical",  // 标记为物理机
        SSHHost:           accessInfo.SSHHost,
        SSHPort:           accessInfo.SSHPort,
        SSHUsername:       accessInfo.SSHUsername,
        SSHPassword:       accessInfo.SSHPassword,
        TargetIP:          machine.IP,
        PhysicalMachineID: &machine.ID,
        UserID:            req.UserID,
        Status:            "running",
    }

    // 6. 更新物理机状态为已分配
    machine.Status = "allocated"
    if err := s.machineDAO.Update(ctx, machine); err != nil {
        return nil, err
    }

    return environment, s.envDAO.Create(ctx, environment)
}
```

#### 3.2.2 容器创建流程

```go
// 环境管理 - 创建容器
func (s *EnvironmentService) CreateEnvironment(ctx context.Context, req *CreateEnvironmentRequest) (*Environment, error) {
    // 1. 生成环境标识符
    envID := utils.GenerateEnvironmentID()

    // 2. 创建Docker容器
    containerInfo, err := s.dockerService.CreateContainer(ctx, &docker.CreateContainerRequest{
        Image:     req.ImageName,
        GPUCount:  req.GPUCount,
        CPUCores:  req.CPUCores,
        Memory:    req.Memory,
        EnvID:     envID,
    })
    if err != nil {
        return nil, err
    }

    // 3. 生成访问信息
    accessInfo := service.GenerateAccessInfo(envID, containerInfo.IP)  // 使用容器IP

    // 4. 存储到Redis
    if err := cache.SetEnvironmentMapping(ctx, envID, accessInfo); err != nil {
        return nil, err
    }

    // 5. 创建环境记录
    environment := &entity.Environment{
        ID:          envID,
        Name:        req.Name,
        Type:        "container",  // 标记为容器
        SSHHost:     accessInfo.SSHHost,
        SSHPort:     accessInfo.SSHPort,
        SSHUsername: accessInfo.SSHUsername,
        SSHPassword: accessInfo.SSHPassword,
        TargetIP:    containerInfo.IP,
        ContainerID: &containerInfo.ID,
        ImageID:     &req.ImageID,
        UserID:      req.UserID,
        Status:      "running",
    }

    return environment, s.envDAO.Create(ctx, environment)
}
```

### 3.3 关键区别总结

| 维度 | 物理机 | 容器 |
|------|--------|------|
| **IP地址** | 物理机的实际IP (如192.168.1.101) | 容器的虚拟IP (如172.17.0.50) |
| **创建方式** | 从机器池中分配 | 通过Docker API创建 |
| **资源管理** | 整机分配,资源独占 | 按需分配,资源共享 |
| **生命周期** | 长期租用,手动回收 | 快速创建销毁 |
| **权限** | 完整root权限 | 容器内受限权限 |
| **计费方式** | 按月计费 | 按小时计费 |
| **适用场景** | 大规模训练,生产环境 | 开发调试,小规模训练 |

## 4. 实现建议

### 4.1 统一的访问信息生成服务

**文件**: `backend/internal/service/access_info.go`

```go
package service

import (
    "crypto/rand"
    "encoding/hex"
    "fmt"
    "math/rand"
    "time"
)

// AccessInfo 访问信息(物理机和容器通用)
type AccessInfo struct {
    EnvironmentID string    `json:"environment_id"`
    Type          string    `json:"type"`           // "physical" 或 "container"
    SSHHost       string    `json:"ssh_host"`
    SSHPort       int       `json:"ssh_port"`
    SSHUsername   string    `json:"ssh_username"`
    SSHPassword   string    `json:"ssh_password"`
    TargetIP      string    `json:"target_ip"`      // 物理机IP或容器IP
    JupyterURL    string    `json:"jupyter_url"`
    CreatedAt     time.Time `json:"created_at"`
}

// GenerateAccessInfo 生成访问信息(通用方法)
func GenerateAccessInfo(envID string, targetIP string, envType string) *AccessInfo {
    sshPort := GenerateSSHPort()
    password := GenerateStrongPassword()

    return &AccessInfo{
        EnvironmentID: envID,
        Type:          envType,
        SSHHost:       GenerateSSHDomain(envID),
        SSHPort:       sshPort,
        SSHUsername:   "root",
        SSHPassword:   password,
        TargetIP:      targetIP,
        JupyterURL:    fmt.Sprintf("https://%s", GenerateContainerDomain(envID, 8888)),
        CreatedAt:     time.Now(),
    }
}

// GenerateSSHDomain 生成SSH访问域名
func GenerateSSHDomain(envID string) string {
    return fmt.Sprintf("%s.ssh.x-gpu.com", envID)
}

// GenerateContainerDomain 生成容器应用访问域名
func GenerateContainerDomain(envID string, port int) string {
    return fmt.Sprintf("%s-%d.container.x-gpu.com", envID, port)
}

// GenerateSSHPort 生成SSH端口(50000-60000范围)
func GenerateSSHPort() int {
    return 50000 + rand.Intn(10000)
}

// GenerateStrongPassword 生成32位强密码
func GenerateStrongPassword() string {
    const charset = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
    password := make([]byte, 32)
    for i := range password {
        password[i] = charset[rand.Intn(len(charset))]
    }
    return string(password)
}
```

### 4.2 Redis映射管理(通用)

**文件**: `backend/pkg/cache/redis_manager.go`

```go
// SetEnvironmentMapping 存储环境映射信息(物理机和容器通用)
func SetEnvironmentMapping(ctx context.Context, accessInfo *AccessInfo) error {
    // 存储目标IP(物理机IP或容器IP)
    key := fmt.Sprintf("env:%s:ip", accessInfo.EnvironmentID)
    if err := RedisClient.Set(ctx, key, accessInfo.TargetIP, 0).Err(); err != nil {
        return err
    }

    // 存储SSH端口
    key = fmt.Sprintf("env:%s:ssh_port", accessInfo.EnvironmentID)
    if err := RedisClient.Set(ctx, key, accessInfo.SSHPort, 0).Err(); err != nil {
        return err
    }

    // 存储类型(可选,用于业务层区分)
    key = fmt.Sprintf("env:%s:type", accessInfo.EnvironmentID)
    if err := RedisClient.Set(ctx, key, accessInfo.Type, 0).Err(); err != nil {
        return err
    }

    // 存储完整访问信息(JSON格式)
    key = fmt.Sprintf("env:%s:access_info", accessInfo.EnvironmentID)
    jsonData, _ := json.Marshal(accessInfo)
    return RedisClient.Set(ctx, key, jsonData, 0).Err()
}

// GetEnvironmentIP 查询环境对应的IP(物理机或容器)
func GetEnvironmentIP(ctx context.Context, envID string) (string, error) {
    key := fmt.Sprintf("env:%s:ip", envID)
    return RedisClient.Get(ctx, key).Result()
}

// GetEnvironmentType 查询环境类型
func GetEnvironmentType(ctx context.Context, envID string) (string, error) {
    key := fmt.Sprintf("env:%s:type", envID)
    return RedisClient.Get(ctx, key).Result()
}
```

### 4.3 前端统一处理

**文件**: `frontend/src/api/environment/types.ts`

```typescript
// 环境类型
export type EnvironmentType = 'physical' | 'container'

// 访问信息接口(物理机和容器通用)
export interface AccessInfo {
  environment_id: string
  type: EnvironmentType
  ssh_host: string
  ssh_port: number
  ssh_username: string
  ssh_password: string
  target_ip: string
  jupyter_url?: string
  created_at: string
}

// 环境接口(通用)
export interface Environment {
  id: string
  name: string
  type: EnvironmentType  // 区分物理机和容器
  ssh_host: string
  ssh_port: number
  ssh_username: string
  ssh_password: string
  target_ip: string
  status: string
  created_at: string
  updated_at: string
}
```

**前端展示组件可以根据type字段显示不同的标识**:

```vue
<template>
  <div class="environment-card">
    <!-- 类型标识 -->
    <el-tag v-if="environment.type === 'physical'" type="success">
      物理机
    </el-tag>
    <el-tag v-else type="info">
      容器
    </el-tag>

    <!-- 访问信息展示(格式相同) -->
    <div class="login-info">
      <div class="login-title">SSH 登录信息</div>
      <div class="login-item">
        <span class="login-label">连接主机：</span>
        <span class="login-value">{{ environment.ssh_host }}</span>
      </div>
      <!-- ... 其他信息 -->
    </div>
  </div>
</template>
```

## 5. 最佳实践

### 5.1 网络隔离

**物理机**:
- 物理机直接连接到数据中心网络
- 使用独立的VLAN进行隔离
- 配置防火墙规则限制访问

**容器**:
- 使用Docker网络进行隔离
- 不同用户的容器使用独立的网络命名空间
- 通过网关统一管理访问

### 5.2 资源监控

**统一监控指标**:
```go
type ResourceMetrics struct {
    EnvironmentID string  `json:"environment_id"`
    Type          string  `json:"type"`  // "physical" 或 "container"
    CPUUsage      float64 `json:"cpu_usage"`
    MemoryUsage   float64 `json:"memory_usage"`
    GPUUsage      float64 `json:"gpu_usage"`
    NetworkIn     int64   `json:"network_in"`
    NetworkOut    int64   `json:"network_out"`
}
```

### 5.3 日志管理

**统一日志格式**:
```json
{
  "timestamp": "2026-02-02T10:30:00Z",
  "environment_id": "6hiflzwte2xnkroq",
  "type": "physical",
  "event": "ssh_login",
  "source_ip": "1.2.3.4",
  "username": "root",
  "status": "success"
}
```

### 5.4 安全建议

1. **密码管理**: 定期轮换SSH密码
2. **访问审计**: 记录所有SSH登录和操作
3. **权限控制**: 物理机和容器使用不同的权限策略
4. **网络隔离**: 确保不同客户的资源相互隔离

## 6. 总结

### 6.1 核心要点

✅ **架构通用性**: 访问管理架构同时支持物理机和容器两种场景
✅ **访问方式统一**: 两者使用相同的SSH域名+端口访问方式
✅ **网关层透明**: Nginx/OpenResty网关无需区分目标类型
✅ **后端灵活**: 通过type字段区分,业务逻辑分别处理
✅ **前端统一**: 使用相同的访问信息展示格式

### 6.2 技术优势

**统一的用户体验**:
- 无论是物理机还是容器,用户都使用相同的访问方式
- 降低学习成本,提升用户满意度

**灵活的资源管理**:
- 物理机适合大规模训练,容器适合开发调试
- 根据不同场景选择最合适的资源类型

**高效的网络架构**:
- 统一的网关层,简化运维管理
- Redis缓存提供高性能的路由查询

**可扩展的设计**:
- 支持未来添加更多资源类型(如虚拟机、K8s Pod等)
- 架构设计具有良好的扩展性

### 6.3 实施建议

1. **优先实施网关层**: 确保基础设施稳定可靠
2. **统一数据模型**: 使用type字段区分不同资源类型
3. **完善监控体系**: 对物理机和容器进行统一监控
4. **加强安全管理**: 根据资源类型实施不同的安全策略

### 6.4 相关文档

- [访问管理和URL映射架构](./访问管理和URL映射架构.md)
- [访问管理架构实施清单](./访问管理架构实施清单.md)
- [端口映射和访问管理框架](./端口映射和访问管理框架.md)

---

**文档版本**: v1.0
**创建日期**: 2026-02-02
**最后更新**: 2026-02-02
**维护者**: RemoteGPU开发团队
**状态**: 设计完成,待实施
