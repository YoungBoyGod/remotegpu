# 局域网机器隔离方案

## 概述

在RemoteGPU平台中,多个客户的物理机和容器运行在同一局域网内,需要实现机器之间的隔离,同时允许访问公共服务。本文档详细说明在不同网络环境下的隔离实现方案。

## 需求分析

### 隔离需求

**基本要求**:
- ✅ 相同网段的机器之间默认不能互相访问
- ✅ 所有机器都可以访问公共服务(存储、监控、网关等)
- ✅ 管理员可以访问所有机器
- ✅ 隔离方案不影响网络性能

**典型场景**:
```
客户A的机器: 192.168.1.10
客户B的机器: 192.168.1.20
公共存储:    192.168.1.100
公共网关:    192.168.1.1

要求:
- 192.168.1.10 ❌ 不能访问 192.168.1.20
- 192.168.1.20 ❌ 不能访问 192.168.1.10
- 192.168.1.10 ✅ 可以访问 192.168.1.100
- 192.168.1.20 ✅ 可以访问 192.168.1.100
- 管理员      ✅ 可以访问所有机器
```

## 方案一: 有路由器/防火墙的情况

### 1.1 VLAN隔离方案(推荐)

#### 1.1.1 架构设计

**网络拓扑**:
```
                    核心交换机
                        |
        +---------------+---------------+
        |               |               |
    VLAN 10         VLAN 20         VLAN 100
   (客户A)         (客户B)         (公共服务)
        |               |               |
   192.168.10.0/24  192.168.20.0/24  192.168.100.0/24
        |               |               |
    客户A机器       客户B机器        存储/网关
```

**VLAN划分**:
- VLAN 10: 客户A的机器 (192.168.10.0/24)
- VLAN 20: 客户B的机器 (192.168.20.0/24)
- VLAN 30: 客户C的机器 (192.168.30.0/24)
- ...
- VLAN 100: 公共服务 (192.168.100.0/24)
- VLAN 200: 管理网络 (192.168.200.0/24)

#### 1.1.2 交换机配置

**创建VLAN**:
```
# Cisco交换机配置示例
vlan 10
  name customer-a
vlan 20
  name customer-b
vlan 100
  name public-services
vlan 200
  name management

# 配置接口VLAN
interface GigabitEthernet1/0/1
  switchport mode access
  switchport access vlan 10
  description customer-a-machine-1

interface GigabitEthernet1/0/2
  switchport mode access
  switchport access vlan 20
  description customer-b-machine-1

interface GigabitEthernet1/0/10
  switchport mode access
  switchport access vlan 100
  description public-storage
```

**配置Trunk端口**(连接到路由器/防火墙):
```
interface GigabitEthernet1/0/24
  switchport mode trunk
  switchport trunk allowed vlan 10,20,100,200
  description trunk-to-firewall
```

#### 1.1.3 防火墙规则配置

**防火墙策略**:

```
# 规则1: 允许所有VLAN访问公共服务VLAN
permit ip any 192.168.100.0/24

# 规则2: 允许管理网络访问所有VLAN
permit ip 192.168.200.0/24 any

# 规则3: 禁止VLAN之间互相访问
deny ip 192.168.10.0/24 192.168.20.0/24
deny ip 192.168.20.0/24 192.168.10.0/24
deny ip 192.168.10.0/24 192.168.30.0/24
# ... 更多禁止规则

# 规则4: 允许访问外网
permit ip any any
```

**使用防火墙区域(Zone-Based Firewall)**:
```
# 定义安全区域
zone security customer-a
zone security customer-b
zone security public-services
zone security management

# 配置区域策略
zone-pair security customer-a-to-public source customer-a destination public-services
  service-policy type inspect allow-to-public

zone-pair security customer-b-to-public source customer-b destination public-services
  service-policy type inspect allow-to-public

# 禁止客户之间互访
zone-pair security customer-a-to-b source customer-a destination customer-b
  service-policy type inspect deny-all
```

#### 1.1.4 优缺点分析

**优点**:
- ✅ 隔离效果最好,二层完全隔离
- ✅ 性能影响小,硬件转发
- ✅ 管理清晰,易于理解
- ✅ 扩展性好,支持大量客户

**缺点**:
- ❌ 需要支持VLAN的交换机
- ❌ VLAN数量有限(通常4096个)
- ❌ 配置相对复杂
- ❌ 需要重新规划IP地址

### 1.2 ACL(访问控制列表)方案

#### 1.2.1 适用场景

**适合以下情况**:
- 所有机器在同一网段(如192.168.1.0/24)
- 不想改变现有IP地址规划
- 交换机支持ACL功能
- 客户数量不是特别多

#### 1.2.2 实现方式

**在三层交换机或路由器上配置ACL**:

```
# 定义客户机器的IP范围
# 客户A: 192.168.1.10-19
# 客户B: 192.168.1.20-29
# 客户C: 192.168.1.30-39
# 公共服务: 192.168.1.100-110

# ACL配置(Cisco风格)
ip access-list extended CUSTOMER-ISOLATION

# 允许访问公共服务
permit ip 192.168.1.0 0.0.0.255 192.168.1.100 0.0.0.15

# 允许管理网络访问
permit ip 192.168.200.0 0.0.0.255 any

# 禁止客户A访问客户B
deny ip 192.168.1.10 0.0.0.15 192.168.1.20 0.0.0.15
deny ip 192.168.1.10 0.0.0.15 192.168.1.30 0.0.0.15

# 禁止客户B访问客户A
deny ip 192.168.1.20 0.0.0.15 192.168.1.10 0.0.0.15
deny ip 192.168.1.20 0.0.0.15 192.168.1.30 0.0.0.15

# 禁止客户C访问其他客户
deny ip 192.168.1.30 0.0.0.15 192.168.1.10 0.0.0.15
deny ip 192.168.1.30 0.0.0.15 192.168.1.20 0.0.0.15

# 允许其他流量(访问外网)
permit ip any any

# 应用ACL到VLAN接口
interface Vlan 1
  ip access-group CUSTOMER-ISOLATION in
```

#### 1.2.3 动态ACL管理

**使用脚本自动生成ACL**:

```python
# acl_generator.py
def generate_customer_isolation_acl(customers, public_services):
    """
    生成客户隔离ACL配置

    customers: [
        {"name": "customer-a", "ip_range": "192.168.1.10-19"},
        {"name": "customer-b", "ip_range": "192.168.1.20-29"},
    ]
    public_services: ["192.168.1.100-110"]
    """
    acl_lines = ["ip access-list extended CUSTOMER-ISOLATION"]

    # 允许访问公共服务
    for service_range in public_services:
        start_ip, end_ip = parse_ip_range(service_range)
        wildcard = calculate_wildcard(start_ip, end_ip)
        acl_lines.append(f"permit ip any {start_ip} {wildcard}")

    # 生成客户间隔离规则
    for i, customer_a in enumerate(customers):
        for customer_b in customers[i+1:]:
            # 禁止A访问B
            acl_lines.append(
                f"deny ip {customer_a['ip_start']} {customer_a['wildcard']} "
                f"{customer_b['ip_start']} {customer_b['wildcard']}"
            )
            # 禁止B访问A
            acl_lines.append(
                f"deny ip {customer_b['ip_start']} {customer_b['wildcard']} "
                f"{customer_a['ip_start']} {customer_a['wildcard']}"
            )

    # 允许其他流量
    acl_lines.append("permit ip any any")

    return "\n".join(acl_lines)
```

#### 1.2.4 优缺点分析

**优点**:
- ✅ 不需要改变IP地址规划
- ✅ 配置相对灵活
- ✅ 可以精确控制访问规则

**缺点**:
- ❌ ACL规则数量随客户增加呈平方级增长
- ❌ 性能影响较大(软件处理)
- ❌ 配置复杂,容易出错
- ❌ 扩展性差,不适合大量客户

## 方案二: 大二层网络的情况(无路由器/防火墙)

### 2.1 Private VLAN (PVLAN) 方案

#### 2.1.1 技术原理

**Private VLAN**是一种特殊的VLAN技术,可以在同一VLAN内实现端口隔离。

**PVLAN端口类型**:
- **Promiscuous Port**(混杂端口): 可以与所有端口通信,用于公共服务
- **Isolated Port**(隔离端口): 只能与Promiscuous端口通信,不能与其他Isolated端口通信
- **Community Port**(社区端口): 可以与同一Community内的端口和Promiscuous端口通信

#### 2.1.2 架构设计

```
                    交换机
                        |
        +---------------+---------------+
        |               |               |
   Promiscuous      Isolated        Isolated
   (公共服务)       (客户A)         (客户B)
        |               |               |
   192.168.1.100   192.168.1.10    192.168.1.20
        ↑               ↑               ↑
        |               |               |
        +-------✅------+-------✅------+
                |               |
                +-------❌------+
```

**通信规则**:
- 客户A(Isolated) ✅ 可以访问 公共服务(Promiscuous)
- 客户B(Isolated) ✅ 可以访问 公共服务(Promiscuous)
- 客户A(Isolated) ❌ 不能访问 客户B(Isolated)

#### 2.1.3 交换机配置

**Cisco交换机配置**:

```
# 创建Primary VLAN
vlan 100
  private-vlan primary
  private-vlan association 101

# 创建Secondary VLAN(Isolated)
vlan 101
  private-vlan isolated

# 配置Promiscuous端口(公共服务)
interface GigabitEthernet1/0/1
  switchport mode private-vlan promiscuous
  switchport private-vlan mapping 100 101
  description public-storage

# 配置Isolated端口(客户A)
interface GigabitEthernet1/0/10
  switchport mode private-vlan host
  switchport private-vlan host-association 100 101
  description customer-a-machine

# 配置Isolated端口(客户B)
interface GigabitEthernet1/0/11
  switchport mode private-vlan host
  switchport private-vlan host-association 100 101
  description customer-b-machine
```

**华为交换机配置**:

```
# 创建VLAN
vlan 100
  private-vlan primary

vlan 101
  private-vlan isolated

# 关联VLAN
vlan 100
  private-vlan association 101

# 配置端口
interface GigabitEthernet0/0/1
  port link-type hybrid
  port private-vlan 100 promiscuous
  description public-service

interface GigabitEthernet0/0/10
  port link-type hybrid
  port private-vlan 100 host 101
  description customer-a

interface GigabitEthernet0/0/11
  port link-type hybrid
  port private-vlan 100 host 101
  description customer-b
```

#### 2.1.4 优缺点分析

**优点**:
- ✅ 二层隔离,性能好
- ✅ 不需要路由器/防火墙
- ✅ 配置相对简单
- ✅ 所有机器在同一网段

**缺点**:
- ❌ 需要交换机支持PVLAN功能
- ❌ 不是所有交换机都支持
- ❌ 灵活性较差,只能实现简单的隔离

### 2.2 Linux iptables方案(推荐)

#### 2.2.1 适用场景

**最适合以下情况**:
- ✅ 使用普通交换机(不支持PVLAN)
- ✅ 所有机器运行Linux系统
- ✅ 需要灵活的访问控制
- ✅ 预算有限,无法购买高级网络设备

#### 2.2.2 技术原理

**在每台Linux主机上配置iptables规则**,实现主机级别的访问控制。

**核心思路**:
1. 默认拒绝所有来自同网段的访问
2. 允许访问公共服务IP
3. 允许管理网络访问
4. 允许访问外网

#### 2.2.3 实现方案

**方案A: 手动配置iptables**

在每台客户机器上执行:

```bash
#!/bin/bash
# customer_isolation.sh

# 定义变量
PUBLIC_SERVICES="192.168.1.100 192.168.1.101 192.168.1.102"  # 公共服务IP列表
MANAGEMENT_NET="192.168.200.0/24"  # 管理网络
LOCAL_NET="192.168.1.0/24"  # 本地网段

# 清空现有规则
iptables -F INPUT
iptables -F OUTPUT

# 设置默认策略
iptables -P INPUT ACCEPT
iptables -P OUTPUT ACCEPT

# 允许本机回环
iptables -A INPUT -i lo -j ACCEPT
iptables -A OUTPUT -o lo -j ACCEPT

# 允许已建立的连接
iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
iptables -A OUTPUT -m state --state ESTABLISHED,RELATED -j ACCEPT

# 允许访问公共服务
for service_ip in $PUBLIC_SERVICES; do
    iptables -A OUTPUT -d $service_ip -j ACCEPT
    iptables -A INPUT -s $service_ip -j ACCEPT
done

# 允许管理网络访问
iptables -A INPUT -s $MANAGEMENT_NET -j ACCEPT
iptables -A OUTPUT -d $MANAGEMENT_NET -j ACCEPT

# 拒绝来自同网段其他机器的访问
iptables -A INPUT -s $LOCAL_NET -j DROP

# 允许访问外网
iptables -A OUTPUT -j ACCEPT

# 保存规则
iptables-save > /etc/iptables/rules.v4
```

**方案B: 使用配置管理工具(Ansible)**

创建Ansible playbook自动部署:

```yaml
# isolation_rules.yml
---
- name: Configure customer isolation
  hosts: customer_machines
  become: yes
  vars:
    public_services:
      - 192.168.1.100
      - 192.168.1.101
      - 192.168.1.102
    management_net: "192.168.200.0/24"
    local_net: "192.168.1.0/24"

  tasks:
    - name: Install iptables-persistent
      apt:
        name: iptables-persistent
        state: present

    - name: Clear existing rules
      iptables:
        chain: "{{ item }}"
        flush: yes
      loop:
        - INPUT
        - OUTPUT

    - name: Allow loopback
      iptables:
        chain: "{{ item.chain }}"
        in_interface: lo
        jump: ACCEPT
      loop:
        - { chain: INPUT }
        - { chain: OUTPUT, out_interface: lo }

    - name: Allow established connections
      iptables:
        chain: "{{ item }}"
        ctstate: ESTABLISHED,RELATED
        jump: ACCEPT
      loop:
        - INPUT
        - OUTPUT

    - name: Allow access to public services
      iptables:
        chain: "{{ item.chain }}"
        destination: "{{ item.ip }}"
        jump: ACCEPT
      loop: "{{ public_services | product(['OUTPUT']) | map('combine') | list }}"

    - name: Allow management network
      iptables:
        chain: INPUT
        source: "{{ management_net }}"
        jump: ACCEPT

    - name: Block local network
      iptables:
        chain: INPUT
        source: "{{ local_net }}"
        jump: DROP

    - name: Save rules
      shell: iptables-save > /etc/iptables/rules.v4
```

#### 2.2.4 集中管理方案

**方案C: 与RemoteGPU平台集成**

在机器分配时自动配置防火墙规则:

```go
// backend/internal/service/firewall.go
package service

import (
    "fmt"
    "os/exec"
)

type FirewallService struct {
    publicServices []string
    managementNet  string
    localNet       string
}

// ConfigureIsolation 配置机器隔离规则
func (s *FirewallService) ConfigureIsolation(machineIP string) error {
    script := s.generateIptablesScript()

    // 通过SSH执行脚本
    cmd := exec.Command("ssh", fmt.Sprintf("root@%s", machineIP), script)
    output, err := cmd.CombinedOutput()
    if err != nil {
        return fmt.Errorf("failed to configure isolation: %v, output: %s", err, output)
    }

    return nil
}

func (s *FirewallService) generateIptablesScript() string {
    script := `#!/bin/bash
iptables -F INPUT
iptables -F OUTPUT
iptables -A INPUT -i lo -j ACCEPT
iptables -A OUTPUT -o lo -j ACCEPT
iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
iptables -A OUTPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
`

    // 添加公共服务规则
    for _, serviceIP := range s.publicServices {
        script += fmt.Sprintf("iptables -A OUTPUT -d %s -j ACCEPT\n", serviceIP)
        script += fmt.Sprintf("iptables -A INPUT -s %s -j ACCEPT\n", serviceIP)
    }

    // 添加管理网络规则
    script += fmt.Sprintf("iptables -A INPUT -s %s -j ACCEPT\n", s.managementNet)
    script += fmt.Sprintf("iptables -A OUTPUT -d %s -j ACCEPT\n", s.managementNet)

    // 拒绝本地网段
    script += fmt.Sprintf("iptables -A INPUT -s %s -j DROP\n", s.localNet)

    // 允许访问外网
    script += "iptables -A OUTPUT -j ACCEPT\n"

    // 保存规则
    script += "iptables-save > /etc/iptables/rules.v4\n"

    return script
}
```

#### 2.2.5 优缺点分析

**优点**:
- ✅ 不需要高级网络设备,普通交换机即可
- ✅ 配置灵活,可以精确控制每台机器的访问规则
- ✅ 成本低,无需额外硬件投资
- ✅ 可以与平台集成,自动化配置
- ✅ 适合Linux环境

**缺点**:
- ❌ 需要在每台机器上配置
- ❌ 管理相对分散
- ❌ 依赖主机防火墙,如果被禁用则失效
- ❌ 性能略有影响(但通常可以忽略)

## 方案对比与选择

### 3.1 方案对比表

| 方案 | 适用场景 | 隔离效果 | 性能影响 | 成本 | 复杂度 | 扩展性 | 推荐度 |
|------|---------|---------|---------|------|--------|--------|--------|
| **VLAN隔离** | 有三层交换机/路由器 | ⭐⭐⭐⭐⭐ | 极小 | 高 | 中 | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
| **ACL方案** | 同网段,有三层设备 | ⭐⭐⭐⭐ | 中 | 中 | 高 | ⭐⭐ | ⭐⭐⭐ |
| **Private VLAN** | 大二层,高级交换机 | ⭐⭐⭐⭐⭐ | 极小 | 中 | 中 | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ |
| **Linux iptables** | 大二层,普通交换机 | ⭐⭐⭐⭐ | 小 | 低 | 低 | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ |

### 3.2 选择建议

#### 3.2.1 有路由器/防火墙的情况

**推荐方案: VLAN隔离**

**理由**:
- ✅ 隔离效果最好,二层完全隔离
- ✅ 性能影响最小,硬件转发
- ✅ 管理清晰,易于维护
- ✅ 扩展性好,支持大量客户

**实施步骤**:
1. 规划VLAN和IP地址段
2. 配置交换机VLAN
3. 配置防火墙/路由器规则
4. 测试验证隔离效果

#### 3.2.2 大二层网络的情况

**情况A: 有高级交换机(支持PVLAN)**

**推荐方案: Private VLAN**

**理由**:
- ✅ 不需要改变IP地址规划
- ✅ 二层隔离,性能好
- ✅ 配置相对简单

**实施步骤**:
1. 确认交换机支持PVLAN功能
2. 规划Promiscuous端口(公共服务)
3. 配置PVLAN
4. 测试验证

**情况B: 普通交换机(推荐)**

**推荐方案: Linux iptables**

**理由**:
- ✅ 成本最低,无需额外硬件
- ✅ 配置灵活,可精确控制
- ✅ 可以与平台集成,自动化配置
- ✅ 适合RemoteGPU平台的场景

**实施步骤**:
1. 准备iptables配置脚本
2. 使用Ansible等工具批量部署
3. 与平台集成,自动配置新机器
4. 定期检查规则是否生效

## 实施注意事项

### 4.1 公共服务规划

**需要定义哪些是公共服务**:
- ✅ 存储服务器(NFS/JuiceFS/S3)
- ✅ 监控服务器(Prometheus/Grafana)
- ✅ 日志服务器(ELK)
- ✅ DNS服务器
- ✅ NTP时间服务器
- ✅ 镜像仓库(Docker Registry)
- ✅ 访问网关(SSH Gateway/Container Gateway)

**建议**:
- 将公共服务放在独立的IP段或VLAN
- 使用固定IP地址,便于配置规则
- 定期审查公共服务列表

### 4.2 管理网络规划

**管理网络的作用**:
- 管理员可以访问所有机器
- 用于配置管理(Ansible/Puppet)
- 用于监控数据采集
- 用于日志收集

**建议**:
- 使用独立的网段(如192.168.200.0/24)
- 限制管理网络的访问权限
- 使用VPN或跳板机访问管理网络

### 4.3 规则持久化

**确保规则重启后生效**:

```bash
# Ubuntu/Debian
apt-get install iptables-persistent
iptables-save > /etc/iptables/rules.v4

# CentOS/RHEL
systemctl enable iptables
service iptables save

# 或使用systemd服务
cat > /etc/systemd/system/iptables-restore.service <<EOF
[Unit]
Description=Restore iptables rules
Before=network-pre.target

[Service]
Type=oneshot
ExecStart=/sbin/iptables-restore /etc/iptables/rules.v4

[Install]
WantedBy=multi-user.target
EOF

systemctl enable iptables-restore
```

### 4.4 监控和告警

**监控隔离规则是否生效**:

```bash
#!/bin/bash
# check_isolation.sh

# 检查iptables规则是否存在
if ! iptables -L INPUT | grep -q "DROP.*192.168.1.0/24"; then
    echo "WARNING: Isolation rules not found!"
    # 发送告警
    curl -X POST "http://monitoring-server/alert" \
         -d "message=Isolation rules missing on $(hostname)"
fi

# 定期执行(crontab)
# */5 * * * * /usr/local/bin/check_isolation.sh
```

## 测试验证

### 5.1 隔离效果测试

**测试步骤**:

```bash
# 在客户A的机器上(192.168.1.10)

# 1. 测试是否能访问公共服务(应该成功)
ping -c 3 192.168.1.100
curl http://192.168.1.100

# 2. 测试是否能访问客户B的机器(应该失败)
ping -c 3 192.168.1.20  # 应该超时或被拒绝
ssh root@192.168.1.20   # 应该连接失败

# 3. 测试是否能访问外网(应该成功)
ping -c 3 8.8.8.8
curl https://www.baidu.com

# 4. 测试管理网络是否能访问(应该成功)
# 从管理网络(192.168.200.x)SSH到本机
```

### 5.2 性能测试

**测试网络性能影响**:

```bash
# 使用iperf3测试网络性能

# 在公共服务器上启动iperf3服务端
iperf3 -s

# 在客户机器上测试
iperf3 -c 192.168.1.100 -t 30

# 对比启用隔离前后的性能差异
```

### 5.3 自动化测试脚本

```python
#!/usr/bin/env python3
# test_isolation.py

import subprocess
import sys

def test_ping(target_ip, should_succeed=True):
    """测试ping连通性"""
    result = subprocess.run(
        ['ping', '-c', '3', '-W', '2', target_ip],
        capture_output=True
    )
    success = (result.returncode == 0)

    if success == should_succeed:
        print(f"✅ PASS: Ping {target_ip} - {'成功' if success else '失败'} (符合预期)")
        return True
    else:
        print(f"❌ FAIL: Ping {target_ip} - {'成功' if success else '失败'} (不符合预期)")
        return False

def main():
    tests_passed = 0
    tests_total = 0

    # 测试访问公共服务(应该成功)
    tests_total += 1
    if test_ping('192.168.1.100', should_succeed=True):
        tests_passed += 1

    # 测试访问其他客户机器(应该失败)
    tests_total += 1
    if test_ping('192.168.1.20', should_succeed=False):
        tests_passed += 1

    # 测试访问外网(应该成功)
    tests_total += 1
    if test_ping('8.8.8.8', should_succeed=True):
        tests_passed += 1

    print(f"\n测试结果: {tests_passed}/{tests_total} 通过")

    if tests_passed == tests_total:
        print("✅ 所有测试通过,隔离配置正确!")
        sys.exit(0)
    else:
        print("❌ 部分测试失败,请检查隔离配置!")
        sys.exit(1)

if __name__ == '__main__':
    main()
```

## 总结

### 6.1 核心要点

本文档详细分析了局域网内机器隔离的多种实现方案,涵盖了有网络设备和大二层网络两种场景。

**关键结论**:

✅ **有路由器/防火墙**: 推荐使用VLAN隔离方案
- 隔离效果最好,性能影响最小
- 需要重新规划IP地址

✅ **大二层+高级交换机**: 推荐使用Private VLAN方案
- 不需要改变IP地址规划
- 二层隔离,性能好

✅ **大二层+普通交换机**: 推荐使用Linux iptables方案
- 成本最低,无需额外硬件
- 配置灵活,可与平台集成
- **最适合RemoteGPU平台的当前场景**

### 6.2 针对RemoteGPU平台的建议

**推荐实施方案**: Linux iptables + 平台集成

**理由**:
1. **成本效益**: 无需购买高级网络设备
2. **灵活性**: 可以精确控制每台机器的访问规则
3. **自动化**: 可以与平台集成,机器分配时自动配置
4. **可维护性**: 使用Ansible等工具统一管理

**实施路线图**:

**阶段一: 准备工作(1-2天)**
1. 规划公共服务IP列表
2. 规划管理网络IP段
3. 编写iptables配置脚本
4. 编写测试验证脚本

**阶段二: 试点部署(3-5天)**
1. 选择2-3台机器进行试点
2. 手动配置iptables规则
3. 测试验证隔离效果
4. 测试性能影响
5. 收集反馈,优化配置

**阶段三: 批量部署(1周)**
1. 使用Ansible批量部署到所有机器
2. 配置规则持久化
3. 配置监控告警
4. 全面测试验证

**阶段四: 平台集成(1-2周)**
1. 在后端实现FirewallService
2. 机器分配时自动配置隔离规则
3. 提供API查询隔离状态
4. 前端展示隔离配置信息

### 6.3 安全加固建议

除了网络隔离,还建议实施以下安全措施:

1. **SSH密钥认证**: 禁用密码登录,使用SSH密钥
2. **定期密码轮换**: 定期更换SSH密码
3. **访问审计**: 记录所有SSH登录和操作
4. **入侵检测**: 部署fail2ban等工具
5. **安全更新**: 定期更新系统和软件包

### 6.4 相关文档

- [访问管理和URL映射架构](./访问管理和URL映射架构.md)
- [访问管理架构实施清单](./访问管理架构实施清单.md)
- [物理机和容器访问架构说明](./物理机和容器访问架构说明.md)

---

**文档版本**: v1.0
**创建日期**: 2026-02-02
**最后更新**: 2026-02-02
**维护者**: RemoteGPU开发团队
**状态**: 设计完成,待实施
