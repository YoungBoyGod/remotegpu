# 三级域名+端口映射访问方案

## 一、方案概述

### 1.1 访问模式

**示例访问方式：**
```bash
# SSH访问
ssh -p 56376 root@6hiflzwte2xnkroq.ssh.x-gpu.com

# Jupyter访问
https://6hiflzwte2xnkroq.jupyter.x-gpu.com:56376

# Code Server访问
https://6hiflzwte2xnkroq.code.x-gpu.com:56377
```

### 1.2 方案特点

**域名结构：**
```
[环境ID].ssh.x-gpu.com:端口
  ↓        ↓      ↓       ↓
三级域名  二级  主域名   端口号
```

**核心特性：**
- ✅ 使用三级域名标识环境
- ✅ 使用二级域名标识服务类型
- ✅ 使用端口号实现隔离
- ✅ 支持多种服务类型

### 1.3 架构设计

```
用户请求
  ↓
DNS解析: *.ssh.x-gpu.com → 负载均衡器IP
  ↓
负载均衡器: 端口56376
  ↓
后端容器/VM: 标准端口22
```

---

## 二、DNS配置

### 2.1 阿里云DNS配置

**配置多个通配符记录：**

```
# SSH服务
记录类型：A
主机记录：*.ssh
记录值：47.100.1.100
TTL：600

# Jupyter服务
记录类型：A
主机记录：*.jupyter
记录值：47.100.1.100
TTL：600

# Code Server服务
记录类型：A
主机记录：*.code
记录值：47.100.1.100
TTL：600

# RDP服务
记录类型：A
主机记录：*.rdp
记录值：47.100.1.100
TTL：600
```

### 2.2 验证DNS配置

```bash
# 测试SSH域名解析
nslookup 6hiflzwte2xnkroq.ssh.x-gpu.com

# 测试Jupyter域名解析
nslookup 6hiflzwte2xnkroq.jupyter.x-gpu.com

# 应该都返回：47.100.1.100
```

---

## 三、端口池管理

### 3.1 端口分配策略

**端口范围规划：**

```
SSH服务：     50000-59999  (10000个端口)
Jupyter服务： 60000-69999  (10000个端口)
Code服务：    70000-79999  (10000个端口)
RDP服务：     80000-89999  (10000个端口)
```

### 3.2 端口池数据结构

**数据库表设计：**

```sql
-- 端口池表
CREATE TABLE IF NOT EXISTS port_pool (
    id BIGSERIAL PRIMARY KEY,
    port INT NOT NULL UNIQUE,
    service_type VARCHAR(32) NOT NULL,  -- ssh, jupyter, code, rdp
    status VARCHAR(32) DEFAULT 'available',  -- available, allocated, reserved
    environment_id VARCHAR(64),  -- 分配给哪个环境
    allocated_at TIMESTAMP,
    released_at TIMESTAMP,
    created_at TIMESTAMP DEFAULT NOW(),

    CONSTRAINT check_port_range CHECK (port >= 50000 AND port <= 89999)
);

-- 创建索引
CREATE INDEX idx_port_pool_status ON port_pool(status);
CREATE INDEX idx_port_pool_service ON port_pool(service_type);
CREATE INDEX idx_port_pool_env ON port_pool(environment_id);

-- 初始化端口池
INSERT INTO port_pool (port, service_type, status)
SELECT
    generate_series(50000, 59999) as port,
    'ssh' as service_type,
    'available' as status;

INSERT INTO port_pool (port, service_type, status)
SELECT
    generate_series(60000, 69999) as port,
    'jupyter' as service_type,
    'available' as status;

INSERT INTO port_pool (port, service_type, status)
SELECT
    generate_series(70000, 79999) as port,
    'code' as service_type,
    'available' as status;

INSERT INTO port_pool (port, service_type, status)
SELECT
    generate_series(80000, 89999) as port,
    'rdp' as service_type,
    'available' as status;
```

### 3.3 端口池管理器实现

**创建 internal/service/port_pool.go：**

```go
package service

import (
    "fmt"
    "sync"
    "time"
    "gorm.io/gorm"
)

// PortPool 端口池实体
type PortPool struct {
    ID            uint      `gorm:"primarykey"`
    Port          int       `gorm:"uniqueIndex;not null"`
    ServiceType   string    `gorm:"index;not null"` // ssh, jupyter, code, rdp
    Status        string    `gorm:"index;default:available"` // available, allocated, reserved
    EnvironmentID string    `gorm:"index"`
    AllocatedAt   *time.Time
    ReleasedAt    *time.Time
    CreatedAt     time.Time
}

// PortPoolManager 端口池管理器
type PortPoolManager struct {
    db *gorm.DB
    mu sync.RWMutex
}

// NewPortPoolManager 创建端口池管理器
func NewPortPoolManager(db *gorm.DB) *PortPoolManager {
    return &PortPoolManager{
        db: db,
    }
}

// AllocatePort 分配端口
func (m *PortPoolManager) AllocatePort(serviceType, environmentID string) (int, error) {
    m.mu.Lock()
    defer m.mu.Unlock()

    var port PortPool

    // 使用事务确保原子性
    err := m.db.Transaction(func(tx *gorm.DB) error {
        // 查找可用端口
        if err := tx.Where("service_type = ? AND status = ?", serviceType, "available").
            Order("port ASC").
            First(&port).Error; err != nil {
            return fmt.Errorf("没有可用的%s端口", serviceType)
        }

        // 更新端口状态
        now := time.Now()
        port.Status = "allocated"
        port.EnvironmentID = environmentID
        port.AllocatedAt = &now

        return tx.Save(&port).Error
    })

    if err != nil {
        return 0, err
    }

    return port.Port, nil
}

// ReleasePort 释放端口
func (m *PortPoolManager) ReleasePort(port int) error {
    m.mu.Lock()
    defer m.mu.Unlock()

    now := time.Now()
    result := m.db.Model(&PortPool{}).
        Where("port = ? AND status = ?", port, "allocated").
        Updates(map[string]interface{}{
            "status":         "available",
            "environment_id": nil,
            "released_at":    now,
        })

    if result.Error != nil {
        return result.Error
    }

    if result.RowsAffected == 0 {
        return fmt.Errorf("端口%d不存在或未被分配", port)
    }

    return nil
}

// ReleasePortsByEnvironment 释放环境的所有端口
func (m *PortPoolManager) ReleasePortsByEnvironment(environmentID string) error {
    m.mu.Lock()
    defer m.mu.Unlock()

    now := time.Now()
    return m.db.Model(&PortPool{}).
        Where("environment_id = ? AND status = ?", environmentID, "allocated").
        Updates(map[string]interface{}{
            "status":         "available",
            "environment_id": nil,
            "released_at":    now,
        }).Error
}

// GetAllocatedPorts 获取环境已分配的端口
func (m *PortPoolManager) GetAllocatedPorts(environmentID string) (map[string]int, error) {
    m.mu.RLock()
    defer m.mu.RUnlock()

    var ports []PortPool
    err := m.db.Where("environment_id = ? AND status = ?", environmentID, "allocated").
        Find(&ports).Error
    if err != nil {
        return nil, err
    }

    result := make(map[string]int)
    for _, p := range ports {
        result[p.ServiceType] = p.Port
    }

    return result, nil
}

// GetAvailableCount 获取可用端口数量
func (m *PortPoolManager) GetAvailableCount(serviceType string) (int64, error) {
    var count int64
    err := m.db.Model(&PortPool{}).
        Where("service_type = ? AND status = ?", serviceType, "available").
        Count(&count).Error
    return count, err
}
```

---

## 四、负载均衡器配置

### 4.1 Nginx Stream模块配置

**编辑 /etc/nginx/nginx.conf：**

```nginx
# 在http块外添加stream块
stream {
    # 日志配置
    log_format proxy '$remote_addr [$time_local] '
                     '$protocol $status $bytes_sent $bytes_received '
                     '$session_time "$upstream_addr" '
                     '"$upstream_bytes_sent" "$upstream_bytes_received" "$upstream_connect_time"';

    access_log /var/log/nginx/stream-access.log proxy;
    error_log /var/log/nginx/stream-error.log;

    # 上游服务器映射
    # 根据服务器名称（SNI）映射到后端
    map $ssl_preread_server_name $backend_name {
        ~^(?<env_id>[^.]+)\.ssh\.x-gpu\.com$ $env_id;
        default "";
    }

    # SSH端口转发（50000-59999）
    # 动态生成配置，或使用include包含动态生成的配置文件
    include /etc/nginx/stream.d/*.conf;
}
```

### 4.2 动态端口配置生成

**创建配置生成脚本：**

```bash
#!/bin/bash
# /usr/local/bin/generate-nginx-stream-config.sh

# 配置目录
STREAM_DIR="/etc/nginx/stream.d"
mkdir -p $STREAM_DIR

# 从数据库读取端口映射
# 这里使用psql示例，实际应该通过API调用
psql -h localhost -U remotegpu_user -d remotegpu -t -A -F"," \
    -c "SELECT port, environment_id, service_type FROM port_pool WHERE status='allocated'" | \
while IFS=',' read -r port env_id service_type; do
    # 生成配置文件
    cat > "$STREAM_DIR/port-${port}.conf" << EOF
# Environment: $env_id, Service: $service_type
server {
    listen ${port};
    proxy_pass ${env_id}-container:22;
    proxy_timeout 10m;
    proxy_connect_timeout 10s;
}
EOF
done

# 测试配置
nginx -t

# 重载Nginx
if [ $? -eq 0 ]; then
    nginx -s reload
    echo "Nginx配置已更新"
else
    echo "Nginx配置测试失败"
    exit 1
fi
```

### 4.3 使用Nginx API动态配置

**Go代码实现动态配置：**

```go
package service

import (
    "fmt"
    "os"
    "os/exec"
    "path/filepath"
)

// NginxConfigManager Nginx配置管理器
type NginxConfigManager struct {
    streamConfigDir string
}

// NewNginxConfigManager 创建Nginx配置管理器
func NewNginxConfigManager(streamConfigDir string) *NginxConfigManager {
    return &NginxConfigManager{
        streamConfigDir: streamConfigDir,
    }
}

// AddPortMapping 添加端口映射配置
func (m *NginxConfigManager) AddPortMapping(port int, envID, serviceType string) error {
    // 确定后端地址
    var backendPort int
    switch serviceType {
    case "ssh":
        backendPort = 22
    case "jupyter":
        backendPort = 8888
    case "code":
        backendPort = 8080
    case "rdp":
        backendPort = 3389
    default:
        return fmt.Errorf("不支持的服务类型: %s", serviceType)
    }

    // 生成配置内容
    config := fmt.Sprintf(`# Environment: %s, Service: %s
server {
    listen %d;
    proxy_pass %s-container:%d;
    proxy_timeout 10m;
    proxy_connect_timeout 10s;
}
`, envID, serviceType, port, envID, backendPort)

    // 写入配置文件
    configFile := filepath.Join(m.streamConfigDir, fmt.Sprintf("port-%d.conf", port))
    if err := os.WriteFile(configFile, []byte(config), 0644); err != nil {
        return fmt.Errorf("写入配置文件失败: %w", err)
    }

    // 重载Nginx
    return m.reloadNginx()
}

// RemovePortMapping 删除端口映射配置
func (m *NginxConfigManager) RemovePortMapping(port int) error {
    configFile := filepath.Join(m.streamConfigDir, fmt.Sprintf("port-%d.conf", port))

    // 删除配置文件
    if err := os.Remove(configFile); err != nil && !os.IsNotExist(err) {
        return fmt.Errorf("删除配置文件失败: %w", err)
    }

    // 重载Nginx
    return m.reloadNginx()
}

// reloadNginx 重载Nginx配置
func (m *NginxConfigManager) reloadNginx() error {
    // 测试配置
    if err := exec.Command("nginx", "-t").Run(); err != nil {
        return fmt.Errorf("Nginx配置测试失败: %w", err)
    }

    // 重载配置
    if err := exec.Command("nginx", "-s", "reload").Run(); err != nil {
        return fmt.Errorf("Nginx重载失败: %w", err)
    }

    return nil
}
```

---

## 五、环境创建集成

### 5.1 完整的环境创建流程

**修改 internal/service/environment.go：**

```go
// CreateEnvironment 创建环境（集成端口分配）
func (s *EnvironmentService) CreateEnvironment(req *CreateEnvironmentRequest) (*Environment, *AccessInfo, error) {
    // 1. 生成环境ID
    envID := fmt.Sprintf("%s", generateRandomID(16)) // 如：6hiflzwte2xnkroq

    // 2. 分配端口
    sshPort, err := s.portPoolManager.AllocatePort("ssh", envID)
    if err != nil {
        return nil, nil, fmt.Errorf("分配SSH端口失败: %w", err)
    }

    jupyterPort, err := s.portPoolManager.AllocatePort("jupyter", envID)
    if err != nil {
        s.portPoolManager.ReleasePort(sshPort) // 回滚
        return nil, nil, fmt.Errorf("分配Jupyter端口失败: %w", err)
    }

    codePort, err := s.portPoolManager.AllocatePort("code", envID)
    if err != nil {
        s.portPoolManager.ReleasePort(sshPort)
        s.portPoolManager.ReleasePort(jupyterPort)
        return nil, nil, fmt.Errorf("分配Code端口失败: %w", err)
    }

    // 3. 生成访问凭证
    password, _ := security.GeneratePassword()
    jupyterToken, _ := security.GenerateToken()

    // 4. 创建容器
    container, err := s.deploymentManager.CreateContainer(&ContainerConfig{
        Image:    "remotegpu/workspace:latest",
        Hostname: envID,
        Env: []string{
            "USERNAME=remotegpu",
            fmt.Sprintf("PASSWORD=%s", password),
            fmt.Sprintf("JUPYTER_TOKEN=%s", jupyterToken),
        },
    })
    if err != nil {
        // 回滚端口分配
        s.portPoolManager.ReleasePort(sshPort)
        s.portPoolManager.ReleasePort(jupyterPort)
        s.portPoolManager.ReleasePort(codePort)
        return nil, nil, err
    }

    // 5. 配置Nginx端口映射
    if err := s.nginxManager.AddPortMapping(sshPort, envID, "ssh"); err != nil {
        // 回滚
        s.deploymentManager.DeleteContainer(container.ID)
        s.portPoolManager.ReleasePortsByEnvironment(envID)
        return nil, nil, err
    }

    if err := s.nginxManager.AddPortMapping(jupyterPort, envID, "jupyter"); err != nil {
        s.nginxManager.RemovePortMapping(sshPort)
        s.deploymentManager.DeleteContainer(container.ID)
        s.portPoolManager.ReleasePortsByEnvironment(envID)
        return nil, nil, err
    }

    if err := s.nginxManager.AddPortMapping(codePort, envID, "code"); err != nil {
        s.nginxManager.RemovePortMapping(sshPort)
        s.nginxManager.RemovePortMapping(jupyterPort)
        s.deploymentManager.DeleteContainer(container.ID)
        s.portPoolManager.ReleasePortsByEnvironment(envID)
        return nil, nil, err
    }

    // 6. 保存环境信息
    env := &entity.Environment{
        ID:          envID,
        UserID:      req.UserID,
        Name:        req.Name,
        Status:      "running",
        ContainerID: container.ID,
    }

    if err := s.envDao.Create(env); err != nil {
        // 回滚所有操作
        s.nginxManager.RemovePortMapping(sshPort)
        s.nginxManager.RemovePortMapping(jupyterPort)
        s.nginxManager.RemovePortMapping(codePort)
        s.deploymentManager.DeleteContainer(container.ID)
        s.portPoolManager.ReleasePortsByEnvironment(envID)
        return nil, nil, err
    }

    // 7. 构建访问信息
    accessInfo := &AccessInfo{
        EnvironmentID: envID,
        SSH: &SSHAccess{
            Host:     fmt.Sprintf("%s.ssh.x-gpu.com", envID),
            Port:     sshPort,
            Username: "remotegpu",
            Password: password,
            Command:  fmt.Sprintf("ssh -p %d remotegpu@%s.ssh.x-gpu.com", sshPort, envID),
        },
        Jupyter: &JupyterAccess{
            URL:   fmt.Sprintf("https://%s.jupyter.x-gpu.com:%d", envID, jupyterPort),
            Token: jupyterToken,
        },
        CodeServer: &CodeServerAccess{
            URL:      fmt.Sprintf("https://%s.code.x-gpu.com:%d", envID, codePort),
            Password: password,
        },
    }

    return env, accessInfo, nil
}
```

### 5.2 环境删除流程

```go
// DeleteEnvironment 删除环境（清理端口）
func (s *EnvironmentService) DeleteEnvironment(envID string) error {
    // 1. 获取环境信息
    env, err := s.envDao.GetByID(envID)
    if err != nil {
        return err
    }

    // 2. 获取已分配的端口
    ports, err := s.portPoolManager.GetAllocatedPorts(envID)
    if err != nil {
        return err
    }

    // 3. 删除Nginx配置
    for _, port := range ports {
        if err := s.nginxManager.RemovePortMapping(port); err != nil {
            log.Printf("删除端口映射失败: %v", err)
        }
    }

    // 4. 释放端口
    if err := s.portPoolManager.ReleasePortsByEnvironment(envID); err != nil {
        log.Printf("释放端口失败: %v", err)
    }

    // 5. 删除容器
    if err := s.deploymentManager.DeleteContainer(env.ContainerID); err != nil {
        return err
    }

    // 6. 删除数据库记录
    return s.envDao.Delete(envID)
}
```

---

## 六、API响应格式

### 6.1 获取访问信息API

**API端点：** `GET /api/v1/environments/{envID}/access`

**响应示例：**

```json
{
  "code": 0,
  "message": "success",
  "data": {
    "environment_id": "6hiflzwte2xnkroq",
    "access_info": {
      "ssh": {
        "host": "6hiflzwte2xnkroq.ssh.x-gpu.com",
        "port": 56376,
        "username": "remotegpu",
        "password": "Xy9#mK2$pL4@qR8z",
        "command": "ssh -p 56376 remotegpu@6hiflzwte2xnkroq.ssh.x-gpu.com"
      },
      "jupyter": {
        "url": "https://6hiflzwte2xnkroq.jupyter.x-gpu.com:60123",
        "token": "a1b2c3d4e5f6g7h8i9j0"
      },
      "code_server": {
        "url": "https://6hiflzwte2xnkroq.code.x-gpu.com:70456",
        "password": "Xy9#mK2$pL4@qR8z"
      }
    }
  }
}
```

---

## 七、方案对比

### 7.1 与通配符域名方案对比

| 特性 | 三级域名+端口方案 | 通配符域名方案 |
|------|------------------|---------------|
| **访问方式** | `6hiflzwte2xnkroq.ssh.x-gpu.com:56376` | `env-abc123.remotegpu.com:22` |
| **端口管理** | 需要管理大量端口 | 使用标准端口 |
| **DNS配置** | 多个通配符记录 | 单个通配符记录 |
| **用户体验** | 需要指定端口 | 标准端口，更简单 |
| **防火墙配置** | 需要开放大量端口 | 只需开放标准端口 |
| **服务隔离** | 通过端口隔离 | 通过反向代理路由 |
| **域名结构** | 更清晰（服务类型分离） | 更简洁 |

### 7.2 优缺点分析

**优点：**
- ✅ 域名结构清晰，服务类型一目了然
- ✅ 可以为不同服务使用不同的二级域名
- ✅ 端口级别的隔离，安全性更高
- ✅ 支持非标准端口，增加安全性

**缺点：**
- ❌ 需要管理大量端口（每个环境3-4个端口）
- ❌ 用户需要记住端口号
- ❌ 防火墙配置复杂
- ❌ 端口资源有限（最多约10000个环境）

---

## 八、部署建议

### 8.1 推荐使用场景

**适合使用此方案的场景：**
1. 需要严格的服务隔离
2. 有足够的端口资源
3. 用户可以接受指定端口
4. 需要非标准端口增强安全性

**不推荐使用的场景：**
1. 环境数量超过10000个
2. 用户体验要求极高
3. 防火墙配置受限
4. 端口管理复杂度不可接受

### 8.2 混合方案建议

**推荐的混合方案：**
- SSH使用标准22端口 + 通配符域名
- Web服务（Jupyter/Code）使用端口映射

```
SSH:     env-abc123.remotegpu.com:22
Jupyter: env-abc123.jupyter.x-gpu.com:60123
Code:    env-abc123.code.x-gpu.com:70456
```

这样可以兼顾用户体验和服务隔离。

---

## 九、总结

### 9.1 实现要点

**核心组件：**
1. ✅ 端口池管理系统
2. ✅ Nginx动态配置
3. ✅ 环境创建集成
4. ✅ 完整的回滚机制

**关键技术：**
- 数据库事务保证端口分配原子性
- Nginx Stream模块实现端口转发
- 动态配置生成和重载
- 完善的错误处理和回滚

### 9.2 后续优化

**可以优化的方向：**
1. 使用Redis缓存端口分配状态
2. 实现端口预留机制
3. 添加端口使用率监控
4. 实现端口自动回收
5. 支持端口范围动态扩展

**监控指标：**
- 端口使用率
- 端口分配失败率
- Nginx配置重载频率
- 端口释放延迟

---

## 十、完整示例

### 10.1 创建环境完整流程

```bash
# 1. 调用API创建环境
curl -X POST http://api.x-gpu.com/v1/environments \
  -H "Content-Type: application/json" \
  -d '{
    "name": "我的GPU环境",
    "image": "remotegpu/workspace:latest"
  }'

# 2. 获取访问信息
curl http://api.x-gpu.com/v1/environments/6hiflzwte2xnkroq/access

# 3. SSH连接
ssh -p 56376 remotegpu@6hiflzwte2xnkroq.ssh.x-gpu.com

# 4. 访问Jupyter
open https://6hiflzwte2xnkroq.jupyter.x-gpu.com:60123

# 5. 访问Code Server
open https://6hiflzwte2xnkroq.code.x-gpu.com:70456
```

### 10.2 环境清理

```bash
# 删除环境
curl -X DELETE http://api.x-gpu.com/v1/environments/6hiflzwte2xnkroq

# 系统自动完成：
# - 释放端口（56376, 60123, 70456）
# - 删除Nginx配置
# - 删除容器
# - 清理数据库记录
```

---

**文档完成！** 这个方案提供了完整的三级域名+端口映射实现，包括端口池管理、Nginx配置、环境集成等所有细节。
