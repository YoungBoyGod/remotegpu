# RemoteGPU 后端实施步骤指南

## 文档说明
本文档提供详细的、可执行的操作步骤，用于指导RemoteGPU后端系统的开发实施。每个步骤都包含：
- 具体操作方法
- 文件路径和命名规范
- 验证方法
- 注意事项

---

## 阶段1：基础数据层（Foundation Layer）

### 目标
建立完整的数据模型和DAO层，为后续开发打好基础。

### 前置条件
- [x] PostgreSQL数据库已配置
- [x] Customer模型和DAO已完成
- [x] 数据库连接正常

---

## 任务1.1.2：创建Workspace模型和DAO

### 步骤1：创建Workspace实体模型

**操作路径**：`internal/model/entity/workspace.go`

**操作方法**：
1. 在`internal/model/entity/`目录下创建新文件`workspace.go`
2. 参考SQL文件`sql/03_users_and_permissions.sql`中的workspaces表结构
3. 定义Workspace结构体，包含以下字段：
   - ID (uint) - 主键
   - UUID (uuid.UUID) - 全局唯一标识
   - OwnerID (uint) - 所有者ID
   - Name (string) - 工作空间名称
   - Description (string) - 描述
   - Type (string) - 类型（personal/team/enterprise）
   - MemberCount (int) - 成员数量
   - Status (string) - 状态（active/archived）
   - CreatedAt (time.Time) - 创建时间
   - UpdatedAt (time.Time) - 更新时间

4. 添加GORM标签：
   - 主键字段添加`gorm:"primaryKey"`
   - UUID字段添加`gorm:"type:uuid;unique;not null"`
   - 外键字段添加`gorm:"not null"`
   - 字符串字段添加长度限制
   - 时间字段添加`gorm:"autoCreateTime"`和`gorm:"autoUpdateTime"`

5. 实现TableName()方法，返回"workspaces"

**验证方法**：
- 检查文件是否创建成功
- 检查结构体字段是否与SQL表结构一致
- 检查GORM标签是否正确

**注意事项**：
- UUID字段需要导入`github.com/google/uuid`包
- Type和Status字段使用string类型，不使用枚举
- 确保字段名使用驼峰命名，GORM会自动转换为下划线

---

### 步骤2：创建WorkspaceDao

**操作路径**：`internal/dao/workspace.go`

**操作方法**：
1. 在`internal/dao/`目录下创建新文件`workspace.go`
2. 定义WorkspaceDao结构体，包含db字段（*gorm.DB）
3. 实现NewWorkspaceDao()构造函数
4. 实现以下方法：

**基础CRUD方法**：
- `Create(workspace *entity.Workspace) error`
  - 使用db.Create()创建记录
  - 返回错误信息

- `GetByID(id uint) (*entity.Workspace, error)`
  - 使用db.First()查询单条记录
  - 处理记录不存在的情况（gorm.ErrRecordNotFound）

- `GetByUUID(uuid string) (*entity.Workspace, error)`
  - 使用db.Where("uuid = ?", uuid).First()查询
  - 处理记录不存在的情况

- `Update(workspace *entity.Workspace) error`
  - 使用db.Save()更新记录
  - 返回错误信息

- `Delete(id uint) error`
  - 使用db.Delete()删除记录
  - 返回错误信息

**查询方法**：
- `GetByOwnerID(ownerID uint) ([]*entity.Workspace, error)`
  - 使用db.Where("owner_id = ?", ownerID).Find()查询
  - 返回工作空间列表

- `GetByType(workspaceType string) ([]*entity.Workspace, error)`
  - 使用db.Where("type = ?", workspaceType).Find()查询
  - 返回工作空间列表

- `GetByStatus(status string) ([]*entity.Workspace, error)`
  - 使用db.Where("status = ?", status).Find()查询
  - 返回工作空间列表

**统计方法**：
- `Count() (int64, error)`
  - 使用db.Model(&entity.Workspace{}).Count()统计总数
  - 返回数量

**验证方法**：
- 检查文件是否创建成功
- 检查所有方法是否实现
- 检查方法签名是否正确
- 检查错误处理是否完善

**注意事项**：
- 所有数据库操作都要处理错误
- 使用gorm.ErrRecordNotFound判断记录不存在
- 查询方法返回空列表而不是nil
- 构造函数中使用pkg/database包获取数据库连接

---

### 步骤3：编写单元测试

**操作路径**：`internal/dao/workspace_test.go`

**操作方法**：
1. 在`internal/dao/`目录下创建新文件`workspace_test.go`
2. 编写测试用例：

**测试用例列表**：
- `TestWorkspaceDao_Create` - 测试创建工作空间
- `TestWorkspaceDao_GetByID` - 测试根据ID查询
- `TestWorkspaceDao_GetByUUID` - 测试根据UUID查询
- `TestWorkspaceDao_Update` - 测试更新工作空间
- `TestWorkspaceDao_Delete` - 测试删除工作空间
- `TestWorkspaceDao_GetByOwnerID` - 测试根据所有者查询

**测试步骤**：
1. 使用测试数据库（或内存数据库）
2. 在每个测试前清理数据
3. 创建测试数据
4. 执行测试操作
5. 验证结果
6. 清理测试数据

**验证方法**：
- 运行`go test ./internal/dao -v`
- 检查所有测试是否通过
- 检查测试覆盖率

**注意事项**：
- 使用t.Run()创建子测试
- 使用assert库进行断言
- 测试数据要有代表性
- 测试后要清理数据

---

## 任务1.1.3：创建WorkspaceMember模型和DAO

### 步骤1：创建WorkspaceMember实体模型

**操作路径**：`internal/model/entity/workspace_member.go`

**操作方法**：
1. 在`internal/model/entity/`目录下创建新文件`workspace_member.go`
2. 参考SQL文件`sql/03_users_and_permissions.sql`中的workspace_members表结构
3. 定义WorkspaceMember结构体，包含以下字段：
   - ID (uint) - 主键
   - WorkspaceID (uint) - 工作空间ID
   - CustomerID (uint) - 用户ID
   - Role (string) - 角色（owner/admin/member/viewer）
   - Status (string) - 状态（active/invited/suspended）
   - JoinedAt (time.Time) - 加入时间
   - CreatedAt (time.Time) - 创建时间

4. 添加GORM标签：
   - 主键字段添加`gorm:"primaryKey"`
   - 外键字段添加`gorm:"not null"`
   - 添加唯一索引`gorm:"uniqueIndex:idx_workspace_customer"`
   - 时间字段添加自动时间戳

5. 实现TableName()方法，返回"workspace_members"

**验证方法**：
- 检查文件是否创建成功
- 检查结构体字段是否与SQL表结构一致
- 检查唯一索引是否正确配置

---

### 步骤2：创建WorkspaceMemberDao

**操作路径**：`internal/dao/workspace_member.go`

**操作方法**：
1. 在`internal/dao/`目录下创建新文件`workspace_member.go`
2. 定义WorkspaceMemberDao结构体
3. 实现NewWorkspaceMemberDao()构造函数
4. 实现以下方法：

**基础CRUD方法**：
- `Create(member *entity.WorkspaceMember) error`
- `GetByID(id uint) (*entity.WorkspaceMember, error)`
- `Update(member *entity.WorkspaceMember) error`
- `Delete(id uint) error`

**查询方法**：
- `GetByWorkspaceID(workspaceID uint) ([]*entity.WorkspaceMember, error)`
  - 查询工作空间的所有成员

- `GetByCustomerID(customerID uint) ([]*entity.WorkspaceMember, error)`
  - 查询用户加入的所有工作空间

- `GetByWorkspaceAndCustomer(workspaceID, customerID uint) (*entity.WorkspaceMember, error)`
  - 查询用户在特定工作空间的成员记录

- `GetByRole(workspaceID uint, role string) ([]*entity.WorkspaceMember, error)`
  - 查询工作空间中特定角色的成员

**统计方法**：
- `CountByWorkspaceID(workspaceID uint) (int64, error)`
  - 统计工作空间的成员数量

**验证方法**：
- 检查文件是否创建成功
- 检查所有方法是否实现
- 检查查询方法是否正确

---

### 步骤3：编写单元测试

**操作路径**：`internal/dao/workspace_member_test.go`

**操作方法**：
1. 创建测试文件
2. 编写测试用例：
   - 测试创建成员
   - 测试查询成员
   - 测试更新成员角色
   - 测试删除成员
   - 测试唯一约束（同一用户不能重复加入同一工作空间）

**验证方法**：
- 运行测试并检查结果
- 验证唯一约束是否生效

---

## 任务1.1.4：创建ResourceQuota模型和DAO

### 步骤1：创建ResourceQuota实体模型

**操作路径**：`internal/model/entity/resource_quota.go`

**操作方法**：
1. 在`internal/model/entity/`目录下创建新文件`resource_quota.go`
2. 参考SQL文件`sql/03_users_and_permissions.sql`中的resource_quotas表结构
3. 定义ResourceQuota结构体，包含以下字段：
   - ID (uint) - 主键
   - CustomerID (uint) - 用户ID
   - WorkspaceID (*uint) - 工作空间ID（可为空）
   - QuotaLevel (string) - 配额级别（free/basic/pro/enterprise）
   - CPUQuota (int) - CPU配额（核心数）
   - MemoryQuota (int) - 内存配额（MB）
   - GPUQuota (int) - GPU配额（数量）
   - StorageQuota (int64) - 存储配额（字节）
   - EnvironmentQuota (int) - 环境数量配额
   - CreatedAt (time.Time) - 创建时间
   - UpdatedAt (time.Time) - 更新时间

4. 添加GORM标签：
   - WorkspaceID使用指针类型，允许NULL
   - 数值字段添加默认值
   - 添加索引

5. 实现TableName()方法，返回"resource_quotas"

**验证方法**：
- 检查字段类型是否正确
- 检查可空字段是否使用指针类型

---

### 步骤2：创建ResourceQuotaDao

**操作路径**：`internal/dao/resource_quota.go`

**操作方法**：
1. 创建ResourceQuotaDao结构体
2. 实现基础CRUD方法
3. 实现查询方法：
   - `GetByCustomerID(customerID uint) (*entity.ResourceQuota, error)`
   - `GetByWorkspaceID(workspaceID uint) (*entity.ResourceQuota, error)`
   - `GetByQuotaLevel(level string) ([]*entity.ResourceQuota, error)`

4. 实现配额检查方法：
   - `CheckQuota(customerID uint, cpu, memory, gpu int, storage int64) (bool, error)`
     - 检查是否超过配额限制

**验证方法**：
- 检查所有方法是否实现
- 检查配额检查逻辑是否正确

---

### 步骤3：编写单元测试

**操作路径**：`internal/dao/resource_quota_test.go`

**操作方法**：
1. 创建测试文件
2. 编写测试用例：
   - 测试创建配额
   - 测试查询配额
   - 测试更新配额
   - 测试配额检查逻辑

**验证方法**：
- 运行测试并检查结果

---

## 阶段1完成验证

### 验证清单

**文件创建检查**：
- [ ] `internal/model/entity/workspace.go` 已创建
- [ ] `internal/model/entity/workspace_member.go` 已创建
- [ ] `internal/model/entity/resource_quota.go` 已创建
- [ ] `internal/dao/workspace.go` 已创建
- [ ] `internal/dao/workspace_member.go` 已创建
- [ ] `internal/dao/resource_quota.go` 已创建

**测试检查**：
- [ ] 所有单元测试通过
- [ ] 测试覆盖率 > 80%

**编译检查**：
- [ ] 运行`go build ./...`无错误
- [ ] 运行`go test ./...`无错误

**代码质量检查**：
- [ ] 运行`go vet ./...`无警告
- [ ] 运行`golint ./...`无严重问题

---

## 任务1.2.1：创建Host模型和DAO

### 步骤1：创建Host实体模型

**操作路径**：`internal/model/entity/host.go`

**操作方法**：
1. 在`internal/model/entity/`目录下创建新文件`host.go`
2. 参考SQL文件`sql/04_hosts_and_devices.sql`中的hosts表结构
3. 定义Host结构体，包含以下字段：
   - ID (string) - 主键（非自增，使用主机标识）
   - Name (string) - 主机名称
   - Hostname (string) - 主机域名
   - IPAddress (string) - IP地址
   - PublicIP (string) - 公网IP
   - OSType (string) - 操作系统类型（linux/windows）
   - OSVersion (string) - 操作系统版本
   - Arch (string) - 架构（x86_64/arm64）
   - DeploymentMode (string) - 部署模式（traditional/kubernetes）
   - K8sNodeName (string) - K8s节点名称
   - Status (string) - 状态（online/offline/maintenance）
   - HealthStatus (string) - 健康状态（healthy/degraded/unhealthy/unknown）
   - TotalCPU (int) - 总CPU核心数
   - TotalMemory (int64) - 总内存（字节）
   - TotalDisk (int64) - 总磁盘（字节）
   - TotalGPU (int) - 总GPU数量
   - UsedCPU (int) - 已用CPU
   - UsedMemory (int64) - 已用内存
   - UsedDisk (int64) - 已用磁盘
   - UsedGPU (int) - 已用GPU
   - SSHPort (int) - SSH端口
   - WinRMPort (*int) - WinRM端口（可为空）
   - AgentPort (int) - Agent端口
   - Labels (datatypes.JSON) - 标签（JSONB）
   - Tags (pq.StringArray) - 标签数组
   - LastHeartbeat (*time.Time) - 最后心跳时间
   - RegisteredAt (time.Time) - 注册时间
   - CreatedAt (time.Time) - 创建时间
   - UpdatedAt (time.Time) - 更新时间

4. 添加GORM标签：
   - ID字段使用`gorm:"primaryKey;type:varchar(64)"`
   - Labels字段使用`gorm:"type:jsonb"`
   - Tags字段使用`gorm:"type:text[]"`
   - 可空字段使用指针类型

5. 实现TableName()方法，返回"hosts"

**验证方法**：
- 检查字段类型是否与SQL表一致
- 检查JSONB和数组类型是否正确配置

**注意事项**：
- 需要导入`gorm.io/datatypes`包（JSONB）
- 需要导入`github.com/lib/pq`包（StringArray）
- ID使用string类型，不是自增主键

---

### 步骤2：创建HostDao

**操作路径**：`internal/dao/host.go`

**操作方法**：
1. 创建HostDao结构体
2. 实现基础CRUD方法：
   - `Create(host *entity.Host) error`
   - `GetByID(id string) (*entity.Host, error)`
   - `Update(host *entity.Host) error`
   - `Delete(id string) error`

3. 实现查询方法：
   - `GetAll() ([]*entity.Host, error)` - 获取所有主机
   - `GetByStatus(status string) ([]*entity.Host, error)` - 按状态查询
   - `GetByDeploymentMode(mode string) ([]*entity.Host, error)` - 按部署模式查询
   - `GetByHealthStatus(healthStatus string) ([]*entity.Host, error)` - 按健康状态查询
   - `GetAvailableHosts(cpu int, memory int64, gpu int) ([]*entity.Host, error)` - 查询可用主机

4. 实现资源管理方法：
   - `UpdateUsedResources(id string, cpu int, memory int64, gpu int) error` - 更新已用资源
   - `UpdateHeartbeat(id string) error` - 更新心跳时间
   - `UpdateStatus(id string, status string) error` - 更新状态

**GetAvailableHosts实现要点**：
- 查询条件：status='online' AND health_status='healthy'
- 资源条件：(total_cpu - used_cpu) >= cpu
- 资源条件：(total_memory - used_memory) >= memory
- 资源条件：(total_gpu - used_gpu) >= gpu
- 按负载排序：ORDER BY (used_cpu::float / total_cpu) ASC

**验证方法**：
- 检查所有方法是否实现
- 检查资源查询逻辑是否正确

---

### 步骤3：编写单元测试

**操作路径**：`internal/dao/host_test.go`

**操作方法**：
1. 创建测试文件
2. 编写测试用例：
   - 测试创建主机
   - 测试查询主机
   - 测试更新资源
   - 测试查询可用主机
   - 测试更新心跳

**验证方法**：
- 运行测试并检查结果

---

## 任务1.2.2：创建GPU模型和DAO

### 步骤1：创建GPU实体模型

**操作路径**：`internal/model/entity/gpu.go`

**操作方法**：
1. 创建新文件`gpu.go`
2. 参考SQL文件`sql/04_hosts_and_devices.sql`中的gpus表结构
3. 定义GPU结构体，包含以下字段：
   - ID (uint) - 主键
   - HostID (string) - 主机ID
   - GPUIndex (int) - GPU索引
   - UUID (string) - GPU UUID（唯一）
   - Name (string) - GPU名称
   - Brand (string) - 品牌（NVIDIA/AMD）
   - Architecture (string) - 架构
   - MemoryTotal (int64) - 显存大小（字节）
   - CUDACores (int) - CUDA核心数
   - ComputeCapability (string) - 计算能力
   - Status (string) - 状态（available/allocated/maintenance）
   - HealthStatus (string) - 健康状态（healthy/unhealthy）
   - AllocatedTo (*string) - 分配给哪个环境（可为空）
   - AllocatedAt (*time.Time) - 分配时间（可为空）
   - PowerLimit (int) - 功率限制
   - TemperatureLimit (int) - 温度限制
   - CreatedAt (time.Time) - 创建时间
   - UpdatedAt (time.Time) - 更新时间

4. 添加GORM标签：
   - UUID字段添加唯一索引
   - 外键字段添加索引
   - 可空字段使用指针类型

5. 实现TableName()方法，返回"gpus"

**验证方法**：
- 检查字段是否完整
- 检查索引配置是否正确

---

### 步骤2：创建GPUDao

**操作路径**：`internal/dao/gpu.go`

**操作方法**：
1. 创建GPUDao结构体
2. 实现基础CRUD方法
3. 实现查询方法：
   - `GetByHostID(hostID string) ([]*entity.GPU, error)` - 查询主机的所有GPU
   - `GetByStatus(status string) ([]*entity.GPU, error)` - 按状态查询
   - `GetAvailableGPUs(hostID string, count int) ([]*entity.GPU, error)` - 查询可用GPU
   - `GetByAllocatedTo(envID string) ([]*entity.GPU, error)` - 查询分配给特定环境的GPU

4. 实现分配方法：
   - `Allocate(id uint, envID string) error` - 分配GPU
   - `Release(id uint) error` - 释放GPU
   - `BatchAllocate(ids []uint, envID string) error` - 批量分配

**GetAvailableGPUs实现要点**：
- 查询条件：host_id = ? AND status = 'available' AND health_status = 'healthy'
- 限制数量：LIMIT ?
- 使用FOR UPDATE行锁（在事务中）

**验证方法**：
- 检查分配逻辑是否正确
- 检查并发安全性

---

### 步骤3：编写单元测试

**操作路径**：`internal/dao/gpu_test.go`

**操作方法**：
1. 创建测试文件
2. 编写测试用例：
   - 测试创建GPU
   - 测试查询GPU
   - 测试分配GPU
   - 测试释放GPU
   - 测试并发分配（重要）

**验证方法**：
- 运行测试并检查结果
- 特别关注并发测试

---

## 任务1.3-1.6：其他数据模型（快速指南）

### 说明
任务1.3到1.6的实施方法与1.1、1.2类似，遵循相同的步骤模式：
1. 创建实体模型（参考SQL文件）
2. 创建DAO层（实现CRUD和查询方法）
3. 编写单元测试

### 任务1.3：Environment和PortMapping
- 参考SQL：`sql/05_environments.sql`
- 实体文件：`internal/model/entity/environment.go`, `port_mapping.go`
- DAO文件：`internal/dao/environment.go`, `port_mapping.go`
- 关键方法：按用户查询、按状态查询、端口分配

### 任务1.4：Image和Dataset
- 参考SQL：`sql/06_data_and_images.sql`
- 实体文件：`internal/model/entity/image.go`, `dataset.go`
- DAO文件：`internal/dao/image.go`, `dataset.go`
- 关键方法：按类型查询、按所有者查询

### 任务1.5：BillingRecord和Invoice
- 参考SQL：`sql/08_billing.sql`
- 实体文件：`internal/model/entity/billing_record.go`, `invoice.go`
- DAO文件：`internal/dao/billing_record.go`, `invoice.go`
- 关键方法：按时间范围查询、统计金额

### 任务1.6：Notification和SystemLog
- 参考SQL：`sql/10_notifications_and_logs.sql`
- 实体文件：`internal/model/entity/notification.go`, `system_log.go`
- DAO文件：`internal/dao/notification.go`, `system_log.go`
- 关键方法：按用户查询、标记已读、日志搜索

---

## 阶段2-5：概要指南

### 阶段2：核心业务层（Service Layer）

**实施方法**：
1. 在`internal/service/`目录下创建Service文件
2. 每个Service对应一个DAO，封装业务逻辑
3. 实现事务处理、权限检查、业务规则验证
4. 参考`internal/service/user.go`的实现模式

**关键Service**：
- WorkspaceService - 工作空间管理
- HostService - 主机管理
- GPUService - GPU资源管理
- EnvironmentService - 环境管理（核心）
- ImageService - 镜像管理
- BillingService - 计费管理

**实施要点**：
- 使用事务确保数据一致性
- 在Service层实现权限检查
- 实现资源分配算法
- 处理业务异常和错误

---

### 阶段3：API控制层（Controller Layer）

**实施方法**：
1. 在`internal/controller/v1/`目录下创建Controller文件
2. 每个Controller对应一个Service
3. 处理HTTP请求、参数验证、响应格式化
4. 参考`internal/controller/v1/user.go`的实现模式

**实施要点**：
- 使用gin框架处理HTTP请求
- 实现参数验证（使用validator库）
- 统一响应格式（使用response包）
- 添加API路由到`internal/router/router.go`

---

### 阶段4：基础设施集成

**实施方法**：
1. 在`pkg/`目录下创建集成包
2. 封装外部服务的客户端
3. 在Service层调用集成包

**关键集成**：
- K8s集成：`pkg/k8s/` - Pod创建和管理
- Harbor集成：`pkg/harbor/` - 镜像管理
- Prometheus集成：`pkg/prometheus/` - 监控数据

---

### 阶段5：高级功能

**实施方法**：
1. 实现定时任务（使用cron库）
2. 实现异步任务（使用消息队列）
3. 添加缓存（使用Redis）
4. 优化性能

---

## 开发流程规范

### 每个任务的标准流程

1. **阅读SQL文件** - 理解表结构和字段含义
2. **创建实体模型** - 定义Go结构体和GORM标签
3. **创建DAO层** - 实现数据库操作方法
4. **编写单元测试** - 验证DAO层功能
5. **创建Service层** - 实现业务逻辑
6. **创建Controller层** - 实现API接口
7. **更新路由** - 添加API路由
8. **测试验证** - 手动测试API功能
9. **Git提交** - 提交代码

### 代码规范

**命名规范**：
- 文件名：小写+下划线（如：`workspace_member.go`）
- 结构体：大驼峰（如：`WorkspaceMember`）
- 方法名：大驼峰（如：`GetByID`）
- 变量名：小驼峰（如：`workspaceID`）

**错误处理**：
- 所有数据库操作都要检查错误
- 使用`errors.Is()`判断特定错误
- 返回有意义的错误信息

**注释规范**：
- 导出的结构体和方法必须添加注释
- 注释以结构体/方法名开头
- 复杂逻辑添加行内注释

---

## 验证和测试

### 单元测试
```bash
# 运行所有测试
go test ./...

# 运行特定包的测试
go test ./internal/dao -v

# 查看测试覆盖率
go test ./... -cover
```

### 编译检查
```bash
# 编译检查
go build ./...

# 代码检查
go vet ./...

# 格式化代码
go fmt ./...
```

### 数据库迁移
```bash
# 执行SQL文件
psql -U remotegpu_user -d remotegpu -f sql/03_users_and_permissions.sql
```

---

## 常见问题和解决方案

### 问题1：GORM标签配置错误
**现象**：字段映射不正确或索引未创建
**解决**：检查GORM标签语法，参考GORM文档

### 问题2：外键约束错误
**现象**：插入数据时报外键约束错误
**解决**：确保关联数据已存在，或使用事务

### 问题3：并发冲突
**现象**：资源分配时出现重复分配
**解决**：使用数据库行锁（FOR UPDATE）

### 问题4：测试数据污染
**现象**：测试之间相互影响
**解决**：每个测试前清理数据，使用事务回滚

---

## 下一步行动

### 立即开始
1. 按照本文档的步骤，从任务1.1.2开始实施
2. 每完成一个任务，运行测试验证
3. 每完成一个模块，进行git提交

### 推荐顺序
1. 完成阶段1所有任务（1-2周）
2. 完成阶段2核心Service（1-2周）
3. 完成阶段3 API层（1-2周）
4. 完成阶段4集成（1-2周）

---

**文档版本**: v1.0
**创建时间**: 2026-01-28
**适用范围**: RemoteGPU后端开发
**预计完成时间**: 8-10周
