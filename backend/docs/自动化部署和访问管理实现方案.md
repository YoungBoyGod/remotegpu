# RemoteGPU 自动化部署和访问管理实现方案

## 一、概述

本文档描述了RemoteGPU平台的自动化部署和访问管理方案，主要解决以下三个核心问题：

1. **域名+端口访问方式**：如何为用户提供友好的域名访问方式，而不是直接使用IP地址
2. **SSH凭证自动生成**：如何自动生成随机密码（固定用户名）并安全管理
3. **服务自动部署**：如何自动部署Jupyter、Code Server等开发工具

---

## 二、域名+端口访问方案

### 2.1 方案A：通配符子域名（强烈推荐）

#### 访问模式

```
SSH访问：ssh remotegpu@env-{环境ID}.remotegpu.com
Jupyter：https://env-{环境ID}.remotegpu.com:8888
或使用路径：https://env-{环境ID}.remotegpu.com/jupyter
```

#### 架构设计

```
用户请求 → DNS解析(*.remotegpu.com)
         → 负载均衡器
         → Nginx/Traefik反向代理
         → 容器/VM
```

#### 优点

- 每个环境独立域名，易于识别和管理
- 支持通配符SSL证书（Let's Encrypt）
- 用户体验好，无需记忆端口号
- 便于实现访问控制和日志审计

#### 实现要点

**1. DNS配置**
```
*.remotegpu.com A记录 → 负载均衡器IP (如: 10.0.1.100)
```

**2. Nginx配置示例**
```nginx
# 通用配置模板
server {
    listen 443 ssl http2;
    server_name ~^env-(?<env_id>[a-z0-9-]+)\.remotegpu\.com$;

    ssl_certificate /etc/nginx/ssl/wildcard.crt;
    ssl_certificate_key /etc/nginx/ssl/wildcard.key;

    # SSH端口转发（使用stream模块）
    # 在nginx.conf的stream块中配置

    # Jupyter服务
    location /jupyter {
        proxy_pass http://backend:8888;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        # WebSocket支持
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
    }

    # Code Server
    location /code {
        proxy_pass http://backend:8080;
        proxy_set_header Host $host;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
    }
}

# SSH端口转发（stream模块）
stream {
    map $ssl_preread_server_name $backend_ssh {
        ~^env-(?<env_id>[a-z0-9-]+)\.remotegpu\.com$ backend-$env_id:22;
    }

    server {
        listen 22;
        proxy_pass $backend_ssh;
        ssl_preread on;
    }
}
```

**3. SSL证书申请**
```bash
# 使用certbot申请通配符证书
certbot certonly --manual \
  --preferred-challenges=dns \
  --email admin@remotegpu.com \
  --server https://acme-v02.api.letsencrypt.org/directory \
  --agree-tos \
  -d *.remotegpu.com
```

### 2.2 方案B：固定域名+动态端口

#### 访问模式

```
SSH访问：ssh remotegpu@remotegpu.com -p 30001
Jupyter：https://remotegpu.com:30002
```

#### 优点

- 配置简单，不需要DNS通配符
- 适合小规模部署

#### 缺点

- 需要管理大量端口（每个环境至少2-3个端口）
- 防火墙配置复杂
- 用户体验较差

#### 端口分配策略

```
环境1: SSH=30001, Jupyter=30002, Code=30003
环境2: SSH=30004, Jupyter=30005, Code=30006
...
```

---

## 三、SSH访问自动化配置方案

### 3.1 用户名和密码管理

#### 固定用户名

```
用户名：remotegpu（或gpuuser）
```

#### 密码生成策略

**生成规则：**
- 长度：16位
- 字符集：大小写字母、数字、特殊字符
- 算法：crypto/rand（安全随机数）

**代码实现：**
```go
package security

import (
    "crypto/rand"
    "math/big"
)

const (
    // 密码字符集
    passwordCharset = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*"
    passwordLength  = 16
)

// GeneratePassword 生成安全的随机密码
func GeneratePassword() (string, error) {
    password := make([]byte, passwordLength)
    charsetLen := big.NewInt(int64(len(passwordCharset)))

    for i := 0; i < passwordLength; i++ {
        randomIndex, err := rand.Int(rand.Reader, charsetLen)
        if err != nil {
            return "", err
        }
        password[i] = passwordCharset[randomIndex.Int64()]
    }

    return string(password), nil
}
```

#### 密码存储策略

**1. 数据库存储（长期）**
```go
import "golang.org/x/crypto/bcrypt"

// 存储时加密
hashedPassword, _ := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)

// 验证时比对
err := bcrypt.CompareHashAndPassword(hashedPassword, []byte(inputPassword))
```

**2. Redis缓存（短期）**
```go
// 存储明文密码，24小时过期，用于首次展示给用户
key := fmt.Sprintf("env:password:%s", envID)
redis.Set(ctx, key, password, 24*time.Hour)
```

**3. 安全建议**
- 密码仅在创建时展示一次
- 建议用户首次登录后修改密码
- 支持SSH密钥认证（推荐）

### 3.2 SSH配置自动化

#### 方案A：Docker容器初始化

**Dockerfile示例：**
```dockerfile
FROM ubuntu:22.04

# 安装SSH服务
RUN apt-get update && apt-get install -y openssh-server && \
    mkdir /var/run/sshd

# 配置SSH
RUN sed -i 's/#PermitRootLogin prohibit-password/PermitRootLogin no/' /etc/ssh/sshd_config && \
    sed -i 's/#PasswordAuthentication yes/PasswordAuthentication yes/' /etc/ssh/sshd_config

# 启动脚本
COPY entrypoint.sh /entrypoint.sh
RUN chmod +x /entrypoint.sh

EXPOSE 22
ENTRYPOINT ["/entrypoint.sh"]
```

**entrypoint.sh：**
```bash
#!/bin/bash

# 从环境变量获取用户名和密码
USERNAME=${USERNAME:-remotegpu}
PASSWORD=${PASSWORD:-changeme}

# 创建用户
useradd -m -s /bin/bash $USERNAME
echo "$USERNAME:$PASSWORD" | chpasswd

# 添加sudo权限
usermod -aG sudo $USERNAME
echo "$USERNAME ALL=(ALL) NOPASSWD:ALL" >> /etc/sudoers

# 启动SSH服务
/usr/sbin/sshd -D
```

**容器创建时传入环境变量：**
```go
containerConfig := &docker.ContainerConfig{
    Image: "remotegpu/workspace:latest",
    Env: []string{
        fmt.Sprintf("USERNAME=%s", "remotegpu"),
        fmt.Sprintf("PASSWORD=%s", generatedPassword),
    },
    ExposedPorts: map[string]struct{}{
        "22/tcp": {},
    },
}
```

#### 方案B：Cloud-Init（VM场景）

**cloud-init配置：**
```yaml
#cloud-config
users:
  - name: remotegpu
    sudo: ALL=(ALL) NOPASSWD:ALL
    shell: /bin/bash
    lock_passwd: false
    passwd: ${HASHED_PASSWORD}  # bcrypt加密后的密码

ssh_pwauth: true
password_authentication: yes

runcmd:
  - systemctl restart sshd
  - echo "SSH配置完成" > /var/log/cloud-init-done.log
```

### 3.3 访问信息API设计

#### API响应格式

```json
{
  "code": 0,
  "message": "success",
  "data": {
    "environment_id": "env-abc123",
    "domain": "env-abc123.remotegpu.com",
    "access_info": {
      "ssh": {
        "host": "env-abc123.remotegpu.com",
        "port": 22,
        "username": "remotegpu",
        "password": "Xy9#mK2$pL4@qR8z",
        "command": "ssh remotegpu@env-abc123.remotegpu.com"
      },
      "jupyter": {
        "url": "https://env-abc123.remotegpu.com:8888",
        "token": "a1b2c3d4e5f6g7h8i9j0",
        "command": "访问上述URL并输入token"
      },
      "code_server": {
        "url": "https://env-abc123.remotegpu.com:8080",
        "password": "Xy9#mK2$pL4@qR8z"
      },
      "rdp": {
        "host": "env-abc123.remotegpu.com",
        "port": 3389,
        "username": "remotegpu",
        "password": "Xy9#mK2$pL4@qR8z"
      }
    },
    "password_expires_at": "2026-02-02T22:41:29Z",
    "note": "密码仅显示一次，请妥善保管。建议首次登录后修改密码或配置SSH密钥。"
  }
}
```

---

## 四、服务自动部署方案

### 4.1 方案A：预配置Docker镜像（推荐）

#### 镜像构建

**Dockerfile：**
```dockerfile
FROM nvidia/cuda:12.0-cudnn8-devel-ubuntu22.04

# 设置环境变量
ENV DEBIAN_FRONTEND=noninteractive
ENV LANG=C.UTF-8
ENV LC_ALL=C.UTF-8

# 安装基础工具
RUN apt-get update && apt-get install -y \
    openssh-server \
    python3 \
    python3-pip \
    git \
    vim \
    curl \
    wget \
    htop \
    tmux \
    sudo \
    && rm -rf /var/lib/apt/lists/*

# 安装Jupyter Lab
RUN pip3 install --no-cache-dir \
    jupyterlab \
    jupyter-server-proxy \
    ipywidgets \
    matplotlib \
    numpy \
    pandas \
    scikit-learn \
    torch \
    torchvision

# 安装Code Server
RUN curl -fsSL https://code-server.dev/install.sh | sh

# 配置SSH
RUN mkdir /var/run/sshd && \
    sed -i 's/#PermitRootLogin prohibit-password/PermitRootLogin no/' /etc/ssh/sshd_config && \
    sed -i 's/#PasswordAuthentication yes/PasswordAuthentication yes/' /etc/ssh/sshd_config

# 创建工作目录
RUN mkdir -p /workspace

# 复制启动脚本
COPY entrypoint.sh /entrypoint.sh
RUN chmod +x /entrypoint.sh

# 暴露端口
EXPOSE 22 8888 8080

# 设置工作目录
WORKDIR /workspace

# 启动脚本
ENTRYPOINT ["/entrypoint.sh"]
```

**entrypoint.sh：**
```bash
#!/bin/bash
set -e

# 从环境变量获取配置
USERNAME=${USERNAME:-remotegpu}
PASSWORD=${PASSWORD:-changeme}
JUPYTER_TOKEN=${JUPYTER_TOKEN:-$(openssl rand -hex 16)}

echo "=== 初始化RemoteGPU工作环境 ==="

# 1. 创建用户
echo "创建用户: $USERNAME"
if ! id "$USERNAME" &>/dev/null; then
    useradd -m -s /bin/bash "$USERNAME"
    echo "$USERNAME:$PASSWORD" | chpasswd
    usermod -aG sudo "$USERNAME"
    echo "$USERNAME ALL=(ALL) NOPASSWD:ALL" >> /etc/sudoers
fi

# 2. 设置工作目录权限
chown -R "$USERNAME:$USERNAME" /workspace

# 3. 启动SSH服务
echo "启动SSH服务..."
/usr/sbin/sshd

# 4. 启动Jupyter Lab（以用户身份运行）
echo "启动Jupyter Lab..."
su - "$USERNAME" -c "cd /workspace && \
    jupyter lab \
    --ip=0.0.0.0 \
    --port=8888 \
    --no-browser \
    --allow-root \
    --NotebookApp.token='$JUPYTER_TOKEN' \
    --NotebookApp.password='' \
    > /tmp/jupyter.log 2>&1 &"

# 5. 启动Code Server（以用户身份运行）
echo "启动Code Server..."
su - "$USERNAME" -c "code-server \
    --bind-addr 0.0.0.0:8080 \
    --auth password \
    --password '$PASSWORD' \
    /workspace \
    > /tmp/code-server.log 2>&1 &"

echo "=== 环境初始化完成 ==="
echo "SSH: 端口22, 用户名: $USERNAME"
echo "Jupyter: 端口8888, Token: $JUPYTER_TOKEN"
echo "Code Server: 端口8080, 密码: $PASSWORD"

# 保持容器运行
tail -f /dev/null
```

#### 镜像构建和推送

```bash
# 构建镜像
docker build -t remotegpu/workspace:latest .

# 推送到私有仓库
docker tag remotegpu/workspace:latest registry.remotegpu.com/workspace:latest
docker push registry.remotegpu.com/workspace:latest
```

### 4.2 环境创建时的服务部署

#### Go代码实现

```go
// CreateEnvironment 创建环境并自动部署服务
func (s *EnvironmentService) CreateEnvironment(req *CreateEnvironmentRequest) (*Environment, *AccessInfo, error) {
    // 1. 生成访问凭证
    password, err := security.GeneratePassword()
    if err != nil {
        return nil, nil, err
    }

    jupyterToken, err := security.GenerateToken()
    if err != nil {
        return nil, nil, err
    }

    // 2. 生成环境ID和域名
    envID := fmt.Sprintf("env-%s", uuid.New().String()[:8])
    domain := fmt.Sprintf("%s.remotegpu.com", envID)

    // 3. 创建容器配置
    containerConfig := &docker.ContainerConfig{
        Image: "remotegpu/workspace:latest",
        Hostname: envID,
        Env: []string{
            "USERNAME=remotegpu",
            fmt.Sprintf("PASSWORD=%s", password),
            fmt.Sprintf("JUPYTER_TOKEN=%s", jupyterToken),
        },
        ExposedPorts: map[string]struct{}{
            "22/tcp":   {},
            "8888/tcp": {},
            "8080/tcp": {},
        },
        Labels: map[string]string{
            "env_id": envID,
            "user_id": fmt.Sprintf("%d", req.UserID),
        },
    }

    // 4. 创建容器
    container, err := s.deploymentManager.CreateContainer(containerConfig)
    if err != nil {
        return nil, nil, err
    }

    // 5. 配置网络和反向代理
    err = s.networkManager.ConfigureProxy(envID, domain, container.ID)
    if err != nil {
        return nil, nil, err
    }

    // 6. 保存环境信息到数据库
    env := &entity.Environment{
        ID:          envID,
        UserID:      req.UserID,
        Name:        req.Name,
        Image:       containerConfig.Image,
        Status:      "running",
        ContainerID: container.ID,
        // ... 其他字段
    }

    err = s.envDao.Create(env)
    if err != nil {
        return nil, nil, err
    }

    // 7. 保存访问信息
    accessInfo := &entity.AccessInfo{
        EnvironmentID:   envID,
        SSHHost:         domain,
        SSHPort:         22,
        SSHUsername:     "remotegpu",
        SSHPasswordHash: hashPassword(password),
        JupyterURL:      fmt.Sprintf("https://%s:8888", domain),
        JupyterToken:    jupyterToken,
        CodeServerURL:   fmt.Sprintf("https://%s:8080", domain),
        ExpiresAt:       time.Now().Add(24 * time.Hour),
    }

    err = s.accessInfoService.Create(accessInfo)
    if err != nil {
        return nil, nil, err
    }

    // 8. 缓存明文密码（24小时）
    cacheKey := fmt.Sprintf("env:password:%s", envID)
    s.cacheManager.Set(cacheKey, password, 24*time.Hour)

    // 9. 返回访问信息（包含明文密码）
    accessInfo.SSHPassword = password // 仅在创建时返回明文

    return env, accessInfo, nil
}
```

### 4.3 健康检查

```go
// HealthCheck 检查环境服务是否正常
func (s *EnvironmentService) HealthCheck(envID string) (*HealthStatus, error) {
    env, err := s.envDao.GetByID(envID)
    if err != nil {
        return nil, err
    }

    status := &HealthStatus{
        EnvironmentID: envID,
        Timestamp:     time.Now(),
    }

    // 1. 检查容器状态
    containerStatus, err := s.deploymentManager.GetContainerStatus(env.ContainerID)
    if err != nil {
        status.ContainerHealthy = false
    } else {
        status.ContainerHealthy = containerStatus == "running"
    }

    // 2. 检查SSH连接
    sshHealthy, err := s.checkSSH(env)
    status.SSHHealthy = sshHealthy

    // 3. 检查Jupyter服务
    jupyterHealthy, err := s.checkJupyter(env)
    status.JupyterHealthy = jupyterHealthy

    // 4. 检查Code Server
    codeServerHealthy, err := s.checkCodeServer(env)
    status.CodeServerHealthy = codeServerHealthy

    // 5. 综合判断
    status.Overall = status.ContainerHealthy &&
                     status.SSHHealthy &&
                     status.JupyterHealthy &&
                     status.CodeServerHealthy

    return status, nil
}
```

---

## 五、数据库设计

### 5.1 access_info表

```sql
CREATE TABLE IF NOT EXISTS access_info (
    id BIGSERIAL PRIMARY KEY,
    environment_id VARCHAR(64) NOT NULL UNIQUE,

    -- SSH访问信息
    ssh_host VARCHAR(256) NOT NULL,  -- env-abc123.remotegpu.com
    ssh_port INT DEFAULT 22,
    ssh_username VARCHAR(64) DEFAULT 'remotegpu',
    ssh_password_hash VARCHAR(256) NOT NULL,  -- bcrypt加密

    -- Jupyter访问信息
    jupyter_url VARCHAR(512),
    jupyter_token VARCHAR(256),

    -- Code Server访问信息
    code_server_url VARCHAR(512),

    -- RDP访问信息（Windows环境）
    rdp_host VARCHAR(256),
    rdp_port INT,
    rdp_username VARCHAR(64),
    rdp_password_hash VARCHAR(256),

    -- 时间戳
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW(),
    expires_at TIMESTAMP,  -- 密码过期时间

    -- 外键
    FOREIGN KEY (environment_id) REFERENCES environments(id) ON DELETE CASCADE
);

-- 创建索引
CREATE INDEX idx_access_info_env ON access_info(environment_id);
CREATE INDEX idx_access_info_expires ON access_info(expires_at);
```

### 5.2 environments表扩展

```sql
-- 添加域名字段
ALTER TABLE environments ADD COLUMN domain VARCHAR(256);
CREATE INDEX idx_environments_domain ON environments(domain);
```

---

## 六、安全考虑

### 6.1 密码安全

1. **生成安全**
   - 使用crypto/rand生成密码
   - 密码长度至少16位
   - 包含大小写字母、数字、特殊字符

2. **存储安全**
   - 数据库存储bcrypt加密（cost=12）
   - Redis缓存明文密码仅24小时
   - 首次展示后建议用户修改

3. **传输安全**
   - API使用HTTPS
   - 密码仅在创建时返回一次
   - 支持SSH密钥认证（推荐）

### 6.2 网络安全

1. **容器网络隔离**
   - 使用Docker网络隔离
   - 仅暴露必要端口
   - 配置防火墙规则

2. **访问控制**
   - JWT token验证
   - IP白名单（可选）
   - 访问日志审计

3. **SSL/TLS**
   - 所有Web服务强制HTTPS
   - 自动续期Let's Encrypt证书
   - 使用TLS 1.2+

### 6.3 审计日志

```go
// 记录访问日志
type AccessLog struct {
    ID            uint      `gorm:"primarykey"`
    EnvironmentID string    `gorm:"index"`
    UserID        uint      `gorm:"index"`
    AccessType    string    // ssh, jupyter, code_server
    IPAddress     string
    UserAgent     string
    Success       bool
    CreatedAt     time.Time
}
```

---

## 七、实现优先级

### Phase 1：核心功能（1-2周）

1. **密码生成和管理**
   - [ ] 实现密码生成函数
   - [ ] 实现密码加密存储
   - [ ] 实现Redis缓存

2. **Docker镜像构建**
   - [ ] 编写Dockerfile
   - [ ] 编写entrypoint.sh
   - [ ] 构建和测试镜像

3. **访问信息API**
   - [ ] 设计数据库表
   - [ ] 实现创建环境API
   - [ ] 实现获取访问信息API

### Phase 2：域名访问（2-3周）

1. **DNS配置**
   - [ ] 配置通配符DNS
   - [ ] 申请SSL证书

2. **反向代理**
   - [ ] 部署Nginx/Traefik
   - [ ] 配置动态路由
   - [ ] 配置SSL

3. **网络管理**
   - [ ] 实现NetworkManager
   - [ ] 实现动态代理配置
   - [ ] 实现健康检查

### Phase 3：服务自动化（1-2周）

1. **镜像优化**
   - [ ] 添加更多开发工具
   - [ ] 优化镜像大小
   - [ ] 添加GPU支持

2. **监控和日志**
   - [ ] 实现健康检查
   - [ ] 实现访问日志
   - [ ] 实现监控告警

3. **用户体验优化**
   - [ ] 一键复制SSH命令
   - [ ] 密码重置功能
   - [ ] SSH密钥管理

---

## 八、测试计划

### 8.1 单元测试

```go
// 测试密码生成
func TestGeneratePassword(t *testing.T) {
    password, err := security.GeneratePassword()
    assert.NoError(t, err)
    assert.Len(t, password, 16)
    // 验证包含各种字符类型
}

// 测试环境创建
func TestCreateEnvironment(t *testing.T) {
    // Mock依赖
    // 测试环境创建流程
    // 验证访问信息生成
}
```

### 8.2 集成测试

1. **端到端测试**
   - 创建环境
   - 获取访问信息
   - SSH连接测试
   - Jupyter访问测试
   - 删除环境

2. **性能测试**
   - 并发创建环境
   - 域名解析性能
   - 反向代理性能

### 8.3 安全测试

1. **密码安全测试**
   - 密码强度验证
   - 加密存储验证
   - 传输安全验证

2. **网络安全测试**
   - 端口扫描测试
   - SQL注入测试
   - XSS测试

---

## 九、运维指南

### 9.1 部署清单

```bash
# 1. 部署DNS
# 配置*.remotegpu.com指向负载均衡器

# 2. 部署Nginx
docker run -d \
  --name nginx-proxy \
  -p 80:80 \
  -p 443:443 \
  -v /etc/nginx/conf.d:/etc/nginx/conf.d \
  -v /etc/nginx/ssl:/etc/nginx/ssl \
  nginx:latest

# 3. 申请SSL证书
certbot certonly --manual \
  --preferred-challenges=dns \
  -d *.remotegpu.com

# 4. 部署应用
docker-compose up -d
```

### 9.2 监控指标

1. **环境指标**
   - 环境创建成功率
   - 环境启动时间
   - 环境健康状态

2. **访问指标**
   - SSH连接成功率
   - Jupyter访问量
   - 平均响应时间

3. **资源指标**
   - CPU使用率
   - 内存使用率
   - 磁盘使用率

### 9.3 故障排查

**问题1：SSH连接失败**
```bash
# 检查容器状态
docker ps | grep env-xxx

# 检查SSH服务
docker exec env-xxx ps aux | grep sshd

# 查看日志
docker logs env-xxx
```

**问题2：Jupyter无法访问**
```bash
# 检查Jupyter进程
docker exec env-xxx ps aux | grep jupyter

# 查看Jupyter日志
docker exec env-xxx cat /tmp/jupyter.log

# 检查端口映射
docker port env-xxx
```

---

## 十、总结

本方案提供了完整的自动化部署和访问管理解决方案，主要特点：

1. **用户友好**：使用域名访问，无需记忆IP和端口
2. **安全可靠**：自动生成强密码，加密存储，支持SSH密钥
3. **自动化**：一键创建环境，自动部署所有服务
4. **可扩展**：模块化设计，易于添加新服务

建议按照Phase 1 → Phase 2 → Phase 3的顺序逐步实现，确保每个阶段都经过充分测试后再进入下一阶段。
