# 离线训练任务

> 所属模块：模块 4 - 任务调度模块
>
> 功能编号：4.1
>
> 优先级：P1（重要）

---

## 1. 功能概述

### 1.1 功能描述

离线训练任务功能支持用户提交长时间运行的训练任务，系统自动调度资源、执行任务、监控进度，并在任务完成后通知用户，适用于深度学习模型训练等计算密集型场景。

### 1.2 业务价值

- ✅ 支持长时间运行的训练任务
- ✅ 自动资源调度和管理
- ✅ 任务进度监控和日志查看
- ✅ 任务失败自动重试
- ✅ 支持分布式训练

---

## 2. 核心功能

### 2.1 任务类型

| 类型 | 说明 | 适用场景 |
|------|------|---------|
| single | 单机训练 | 小规模模型训练 |
| distributed | 分布式训练 | 大规模模型训练 |
| hyperparameter | 超参数搜索 | 自动调参 |
| pipeline | 训练流水线 | 多阶段训练 |

### 2.2 任务生命周期

```yaml
任务状态流转:
  pending → scheduled → running → completed
                    ↓
                  failed → retrying → running
                    ↓
                  cancelled
```

---

## 3. 数据模型

```sql
CREATE TABLE training_jobs (
    id BIGSERIAL PRIMARY KEY,
    uuid VARCHAR(64) UNIQUE NOT NULL,
    customer_id BIGINT NOT NULL,
    workspace_id BIGINT,

    -- 任务信息
    name VARCHAR(256) NOT NULL,
    description TEXT,
    job_type VARCHAR(32) DEFAULT 'single',

    -- 资源需求
    cpu_cores INT DEFAULT 4,
    memory_gb INT DEFAULT 16,
    gpu_count INT DEFAULT 1,
    gpu_type VARCHAR(64),

    -- 执行配置
    image VARCHAR(256) NOT NULL,
    command TEXT NOT NULL,
    working_dir VARCHAR(512) DEFAULT '/workspace',
    env_vars JSONB,

    -- 数据集和模型
    dataset_ids BIGINT[],
    output_path VARCHAR(512),

    -- 状态
    status VARCHAR(32) DEFAULT 'pending',
    progress INT DEFAULT 0,
    retry_count INT DEFAULT 0,
    max_retries INT DEFAULT 3,

    -- 时间
    submitted_at TIMESTAMP DEFAULT NOW(),
    scheduled_at TIMESTAMP,
    started_at TIMESTAMP,
    completed_at TIMESTAMP,

    FOREIGN KEY (customer_id) REFERENCES customers(id)
);
```

---

## 4. 任务调度实现

### 4.1 任务调度器

```go
// 任务调度器
type JobScheduler struct {
    db              *gorm.DB
    resourceManager *ResourceManager
    jobQueue        chan *TrainingJob
}

// 启动调度器
func (s *JobScheduler) Start() {
    go s.scheduleLoop()
    go s.monitorLoop()
}

// 调度循环
func (s *JobScheduler) scheduleLoop() {
    ticker := time.NewTicker(10 * time.Second)
    defer ticker.Stop()

    for range ticker.C {
        // 查询待调度任务
        var jobs []TrainingJob
        s.db.Where("status = ?", "pending").
            Order("submitted_at ASC").
            Limit(10).
            Find(&jobs)

        for _, job := range jobs {
            // 检查资源是否满足
            resources, err := s.resourceManager.FindAvailableResources(ResourceRequest{
                CPU:      job.CPUCores,
                Memory:   job.MemoryGB * 1024 * 1024 * 1024,
                GPU:      job.GPUCount,
                GPUType:  job.GPUType,
            })

            if err != nil {
                continue
            }

            // 分配资源并启动任务
            if err := s.startJob(&job, resources); err != nil {
                log.Printf("启动任务失败: %v", err)
                continue
            }

            // 更新任务状态
            s.db.Model(&job).Updates(map[string]interface{}{
                "status":       "scheduled",
                "scheduled_at": time.Now(),
            })
        }
    }
}

// 启动任务
func (s *JobScheduler) startJob(job *TrainingJob, resources *AllocatedResources) error {
    // 创建容器
    containerConfig := &docker.Config{
        Image:      job.Image,
        Cmd:        strings.Split(job.Command, " "),
        WorkingDir: job.WorkingDir,
        Env:        convertEnvVars(job.EnvVars),
    }

    hostConfig := &docker.HostConfig{
        Resources: docker.Resources{
            Memory:   job.MemoryGB * 1024 * 1024 * 1024,
            NanoCPUs: int64(job.CPUCores) * 1000000000,
        },
        DeviceRequests: []docker.DeviceRequest{
            {
                Count:        job.GPUCount,
                Capabilities: [][]string{{"gpu"}},
            },
        },
    }

    container, err := s.dockerClient.CreateContainer(docker.CreateContainerOptions{
        Config:     containerConfig,
        HostConfig: hostConfig,
    })

    if err != nil {
        return err
    }

    // 启动容器
    if err := s.dockerClient.StartContainer(container.ID, nil); err != nil {
        return err
    }

    // 更新任务状态
    s.db.Model(job).Updates(map[string]interface{}{
        "status":     "running",
        "started_at": time.Now(),
    })

    return nil
}
```

### 4.2 任务监控

```go
// 监控循环
func (s *JobScheduler) monitorLoop() {
    ticker := time.NewTicker(30 * time.Second)
    defer ticker.Stop()

    for range ticker.C {
        // 查询运行中的任务
        var jobs []TrainingJob
        s.db.Where("status = ?", "running").Find(&jobs)

        for _, job := range jobs {
            // 检查容器状态
            container, err := s.dockerClient.InspectContainer(job.ContainerID)
            if err != nil {
                continue
            }

            // 容器已停止
            if !container.State.Running {
                if container.State.ExitCode == 0 {
                    // 任务成功完成
                    s.db.Model(&job).Updates(map[string]interface{
                        "status":       "completed",
                        "progress":     100,
                        "completed_at": time.Now(),
                    })
                } else {
                    // 任务失败
                    s.handleJobFailure(&job)
                }
            }
        }
    }
}

// 处理任务失败
func (s *JobScheduler) handleJobFailure(job *TrainingJob) {
    if job.RetryCount < job.MaxRetries {
        // 重试
        s.db.Model(job).Updates(map[string]interface{}{
            "status":      "retrying",
            "retry_count": job.RetryCount + 1,
        })
    } else {
        // 标记为失败
        s.db.Model(job).Updates(map[string]interface{}{
            "status":       "failed",
            "completed_at": time.Now(),
        })
    }
}
```

---

## 5. API 接口

### 5.1 提交训练任务

```go
POST /api/training-jobs
Body: {
  "name": "ResNet50 训练",
  "description": "ImageNet 数据集训练",
  "job_type": "single",
  "cpu_cores": 8,
  "memory_gb": 32,
  "gpu_count": 2,
  "gpu_type": "RTX 4090",
  "image": "pytorch/pytorch:2.0-cuda11.8",
  "command": "python train.py --epochs 100",
  "dataset_ids": [1, 2],
  "output_path": "/workspace/output"
}

Response: {
  "job_id": "job-abc123",
  "status": "pending",
  "submitted_at": "2026-01-26T10:00:00Z"
}
```

### 5.2 查询任务状态

```go
GET /api/training-jobs/:id

Response: {
  "job_id": "job-abc123",
  "name": "ResNet50 训练",
  "status": "running",
  "progress": 45,
  "started_at": "2026-01-26T10:05:00Z"
}
```

### 5.3 查询任务日志

```go
GET /api/training-jobs/:id/logs
Query: tail=100

Response: {
  "logs": [
    "Epoch 1/100 - Loss: 2.345",
    "Epoch 2/100 - Loss: 2.123",
    "..."
  ]
}
```

### 5.4 取消任务

```go
POST /api/training-jobs/:id/cancel

Response: {
  "status": "cancelled"
}
```

---

## 6. 前端界面

```vue
<template>
  <el-card>
    <h3>训练任务</h3>

    <el-button type="primary" @click="showCreateDialog">
      创建训练任务
    </el-button>

    <el-table :data="jobs" style="margin-top: 20px">
      <el-table-column prop="name" label="任务名称" />
      <el-table-column prop="job_type" label="类型" />
      <el-table-column label="资源">
        <template #default="{ row }">
          {{ row.cpu_cores }}C / {{ row.memory_gb }}GB / {{ row.gpu_count }}GPU
        </template>
      </el-table-column>
      <el-table-column prop="status" label="状态">
        <template #default="{ row }">
          <el-tag :type="getStatusType(row.status)">
            {{ row.status }}
          </el-tag>
        </template>
      </el-table-column>
      <el-table-column label="进度">
        <template #default="{ row }">
          <el-progress :percentage="row.progress" />
        </template>
      </el-table-column>
      <el-table-column label="操作">
        <template #default="{ row }">
          <el-button size="small" @click="viewLogs(row)">
            查看日志
          </el-button>
          <el-button
            size="small"
            type="danger"
            @click="cancelJob(row)"
            v-if="row.status === 'running' || row.status === 'pending'"
          >
            取消
          </el-button>
        </template>
      </el-table-column>
    </el-table>
  </el-card>
</template>

<script setup>
import { ref, onMounted } from 'vue'
import { ElMessage } from 'element-plus'

const jobs = ref([])

const loadJobs = async () => {
  try {
    const response = await fetch('/api/training-jobs')
    jobs.value = await response.json()
  } catch (error) {
    ElMessage.error('加载失败: ' + error.message)
  }
}

const cancelJob = async (job) => {
  try {
    await fetch(`/api/training-jobs/${job.id}/cancel`, {
      method: 'POST'
    })
    ElMessage.success('任务已取消')
    loadJobs()
  } catch (error) {
    ElMessage.error('取消失败: ' + error.message)
  }
}

onMounted(() => {
  loadJobs()
  setInterval(loadJobs, 10000)
})
</script>
```

---

## 7. 测试用例

| 用例 | 场景 | 预期结果 |
|------|------|---------|
| TC-01 | 提交训练任务 | 任务创建成功，状态为 pending |
| TC-02 | 资源充足时调度任务 | 任务自动调度并启动 |
| TC-03 | 资源不足时排队 | 任务保持 pending 状态 |
| TC-04 | 任务正常完成 | 状态更新为 completed |
| TC-05 | 任务失败自动重试 | 重试次数增加，重新调度 |
| TC-06 | 达到最大重试次数 | 状态更新为 failed |
| TC-07 | 取消运行中的任务 | 容器停止，状态为 cancelled |

---

**文档版本：** v1.0
**创建日期：** 2026-01-26

