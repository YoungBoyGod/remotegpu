# 端口管理

> 所属模块：模块 4 - 资源调度模块
>
> 功能编号：4.2
>
> 优先级：P0（必须）

---

## 1. 功能概述

### 1.1 功能描述

端口管理功能负责管理 SSH、RDP、JupyterLab 等服务的端口分配和释放，确保端口不冲突，支持端口池管理和动态分配，为环境提供唯一的访问端口。

### 1.2 业务价值

- ✅ 自动分配端口，避免端口冲突
- ✅ 端口池管理，提高端口利用率
- ✅ 支持端口回收和重用
- ✅ 端口使用情况统计和监控

### 1.3 端口规划

```yaml
端口范围规划:
  SSH (Linux):     30000-31000  (1000 个端口)
  SSH (Windows):   31000-32000  (1000 个端口)
  RDP (Windows):   33000-34000  (1000 个端口)
  JupyterLab:      38000-39000  (1000 个端口)
  自定义服务:       40000-41000  (1000 个端口)
  预留:            41000-42000  (1000 个端口)
```

---

## 2. 核心功能

### 2.1 端口池管理

**端口池定义：**
```go
type PortPool struct {
    Name      string          // 端口池名称
    StartPort int             // 起始端口
    EndPort   int             // 结束端口
    UsedPorts map[int]bool    // 已使用的端口
    mu        sync.Mutex      // 并发锁
}

// 端口池配置
var portPools = map[string]*PortPool{
    "ssh-linux": {
        Name:      "ssh-linux",
        StartPort: 30000,
        EndPort:   31000,
        UsedPorts: make(map[int]bool),
    },
    "ssh-windows": {
        Name:      "ssh-windows",
        StartPort: 31000,
        EndPort:   32000,
        UsedPorts: make(map[int]bool),
    },
    "rdp": {
        Name:      "rdp",
        StartPort: 33000,
        EndPort:   34000,
        UsedPorts: make(map[int]bool),
    },
    "jupyter": {
        Name:      "jupyter",
        StartPort: 38000,
        EndPort:   39000,
        UsedPorts: make(map[int]bool),
    },
}
```

### 2.2 端口分配

**分配策略：**
1. **顺序分配**：从起始端口开始，找到第一个可用端口
2. **随机分配**：随机选择可用端口（可选）
3. **指定分配**：分配指定的端口（需检查是否可用）

**实现代码：**
```go
// 端口管理器
type PortManager struct {
    db    *gorm.DB
    pools map[string]*PortPool
}

// 分配端口
func (pm *PortManager) AllocatePort(poolName string) (int, error) {
    pool, exists := pm.pools[poolName]
    if !exists {
        return 0, errors.New("端口池不存在")
    }

    pool.mu.Lock()
    defer pool.mu.Unlock()

    // 查找可用端口
    for port := pool.StartPort; port < pool.EndPort; port++ {
        if !pool.UsedPorts[port] {
            // 检查数据库中是否已分配
            var count int64
            pm.db.Model(&PortMapping{}).
                Where("external_port = ? AND status = 'active'", port).
                Count(&count)

            if count == 0 {
                pool.UsedPorts[port] = true
                return port, nil
            }
        }
    }

    return 0, errors.New("端口池已满")
}

// 释放端口
func (pm *PortManager) ReleasePort(port int) error {
    // 查找端口所属的池
    for _, pool := range pm.pools {
        if port >= pool.StartPort && port < pool.EndPort {
            pool.mu.Lock()
            delete(pool.UsedPorts, port)
            pool.mu.Unlock()

            // 更新数据库
            return pm.db.Model(&PortMapping{}).
                Where("external_port = ?", port).
                Updates(map[string]interface{}{
                    "status":      "released",
                    "released_at": time.Now(),
                }).Error
        }
    }

    return errors.New("端口不在任何端口池中")
}
```

### 2.3 端口映射

**映射类型：**
- **SSH 映射**：外部端口 → 容器 22 端口
- **RDP 映射**：外部端口 → Windows 3389 端口
- **JupyterLab 映射**：外部端口 → 容器 8888 端口

**实现方式：**
```bash
# Linux 使用 iptables
iptables -t nat -A PREROUTING -p tcp --dport 30001 -j DNAT --to-destination 172.17.0.2:22

# 或使用 Docker 端口映射
docker run -p 30001:22 ubuntu20-pytorch:2.0
```

### 2.4 端口回收

**回收策略：**
1. **主动回收**：环境销毁时立即释放端口
2. **定期回收**：每天凌晨 2 点回收已释放超过 7 天的端口记录
3. **异常回收**：检测到端口无人使用超过 24 小时，自动回收

**回收实现：**
```go
// 定期回收端口
func (pm *PortManager) ScheduledRecycle() {
    ticker := time.NewTicker(24 * time.Hour)
    go func() {
        for range ticker.C {
            // 回收已释放超过 7 天的端口记录
            pm.db.Where("status = 'released' AND released_at < ?",
                time.Now().Add(-7*24*time.Hour)).
                Delete(&PortMapping{})

            // 检测异常端口
            pm.detectAbandonedPorts()
        }
    }()
}

// 检测被遗弃的端口
func (pm *PortManager) detectAbandonedPorts() {
    var mappings []PortMapping
    pm.db.Where("status = 'active'").Find(&mappings)

    for _, mapping := range mappings {
        // 检查环境是否还存在
        var env Environment
        if err := pm.db.Where("id = ?", mapping.EnvID).First(&env).Error; err != nil {
            // 环境不存在，释放端口
            pm.ReleasePort(mapping.ExternalPort)
        }
    }
}
```

---

## 3. 数据模型

### 3.1 端口映射表

```sql
CREATE TABLE port_mappings (
    id BIGSERIAL PRIMARY KEY,
    env_id VARCHAR(64) NOT NULL,
    host_id VARCHAR(64),

    -- 端口信息
    service_type VARCHAR(32) NOT NULL,     -- ssh, rdp, jupyter, custom
    external_port INT NOT NULL UNIQUE,     -- 外部端口
    internal_port INT NOT NULL,            -- 内部端口

    -- 状态
    status VARCHAR(20) DEFAULT 'active',   -- active, released

    -- 时间戳
    allocated_at TIMESTAMP DEFAULT NOW(),
    released_at TIMESTAMP,

    FOREIGN KEY (env_id) REFERENCES environments(id) ON DELETE CASCADE,
    INDEX idx_env_id (env_id),
    INDEX idx_external_port (external_port),
    INDEX idx_status (status)
);
```

### 3.2 端口池配置表

```sql
CREATE TABLE port_pools (
    id BIGSERIAL PRIMARY KEY,
    name VARCHAR(128) NOT NULL UNIQUE,
    description TEXT,

    -- 端口范围
    port_range_start INT NOT NULL,
    port_range_end INT NOT NULL,

    -- 统计信息
    total_ports INT NOT NULL,
    used_ports INT DEFAULT 0,

    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

-- 初始化端口池
INSERT INTO port_pools (name, description, port_range_start, port_range_end, total_ports) VALUES
('ssh-linux', 'Linux SSH 端口池', 30000, 31000, 1000),
('ssh-windows', 'Windows SSH 端口池', 31000, 32000, 1000),
('rdp', 'Windows RDP 端口池', 33000, 34000, 1000),
('jupyter', 'JupyterLab 端口池', 38000, 39000, 1000),
('custom', '自定义服务端口池', 40000, 41000, 1000);
```

---

## 4. API 接口

### 4.1 分配端口

```go
// POST /internal/ports/allocate
func AllocatePort(c *gin.Context) {
    var req struct {
        EnvID        string `json:"env_id" binding:"required"`
        ServiceType  string `json:"service_type" binding:"required"`
        InternalPort int    `json:"internal_port" binding:"required"`
    }

    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(400, gin.H{"error": err.Error()})
        return
    }

    // 根据服务类型选择端口池
    poolName := getPoolName(req.ServiceType)

    // 分配端口
    externalPort, err := portManager.AllocatePort(poolName)
    if err != nil {
        c.JSON(503, gin.H{"error": "端口池已满"})
        return
    }

    // 创建端口映射记录
    mapping := &PortMapping{
        EnvID:        req.EnvID,
        ServiceType:  req.ServiceType,
        ExternalPort: externalPort,
        InternalPort: req.InternalPort,
        Status:       "active",
    }

    if err := db.Create(mapping).Error; err != nil {
        portManager.ReleasePort(externalPort)
        c.JSON(500, gin.H{"error": "创建映射失败"})
        return
    }

    c.JSON(200, gin.H{
        "external_port": externalPort,
        "internal_port": req.InternalPort,
    })
}
```

### 4.2 释放端口

```go
// POST /internal/ports/release
func ReleasePort(c *gin.Context) {
    var req struct {
        EnvID string `json:"env_id" binding:"required"`
    }

    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(400, gin.H{"error": err.Error()})
        return
    }

    // 查询环境的所有端口映射
    var mappings []PortMapping
    db.Where("env_id = ? AND status = 'active'", req.EnvID).Find(&mappings)

    // 释放所有端口
    for _, mapping := range mappings {
        portManager.ReleasePort(mapping.ExternalPort)
    }

    c.JSON(200, gin.H{
        "released_count": len(mappings),
        "status":         "success",
    })
}
```

### 4.3 查询端口使用情况

```go
// GET /api/ports/stats
func GetPortStats(c *gin.Context) {
    stats := make(map[string]interface{})

    for name, pool := range portManager.pools {
        usedCount := len(pool.UsedPorts)
        totalCount := pool.EndPort - pool.StartPort

        stats[name] = gin.H{
            "total":       totalCount,
            "used":        usedCount,
            "available":   totalCount - usedCount,
            "usage_rate":  float64(usedCount) / float64(totalCount) * 100,
        }
    }

    c.JSON(200, stats)
}
```

---

## 5. 前端界面

### 5.1 端口使用情况页面

```vue
<template>
  <el-card>
    <h3>端口使用情况</h3>

    <el-row :gutter="20">
      <el-col :span="6" v-for="(pool, name) in portStats" :key="name">
        <el-card>
          <h4>{{ pool.name }}</h4>
          <el-progress
            :percentage="pool.usage_rate"
            :color="getProgressColor(pool.usage_rate)"
          />
          <p>已用: {{ pool.used }} / {{ pool.total }}</p>
          <p>可用: {{ pool.available }}</p>
        </el-card>
      </el-col>
    </el-row>

    <!-- 端口映射列表 -->
    <el-table :data="portMappings" style="margin-top: 20px">
      <el-table-column prop="env_id" label="环境 ID" />
      <el-table-column prop="service_type" label="服务类型" />
      <el-table-column prop="external_port" label="外部端口" />
      <el-table-column prop="internal_port" label="内部端口" />
      <el-table-column prop="status" label="状态">
        <template #default="{ row }">
          <el-tag :type="row.status === 'active' ? 'success' : 'info'">
            {{ row.status }}
          </el-tag>
        </template>
      </el-table-column>
    </el-table>
  </el-card>
</template>

<script setup lang="ts">
import { ref, onMounted } from 'vue';
import { getPortStats, getPortMappings } from '@/api/ports';

const portStats = ref({});
const portMappings = ref([]);

const getProgressColor = (percentage: number) => {
  if (percentage < 70) return '#67C23A';
  if (percentage < 90) return '#E6A23C';
  return '#F56C6C';
};

onMounted(async () => {
  portStats.value = await getPortStats();
  portMappings.value = await getPortMappings();
});
</script>
```

---

## 6. 测试用例

| 用例编号 | 测试场景 | 预期结果 |
|---------|---------|---------|
| TC-01 | 分配端口（端口池有空闲） | 分配成功，返回端口号 |
| TC-02 | 分配端口（端口池已满） | 分配失败，返回错误 |
| TC-03 | 释放端口 | 端口状态更新为 released |
| TC-04 | 并发分配端口 | 无端口冲突 |
| TC-05 | 端口回收 | 已释放端口可重新分配 |
| TC-06 | 端口池使用率 > 90% | 触发告警 |

---

## 7. 监控告警

### 7.1 监控指标

```yaml
监控指标:
  - 端口池使用率
  - 端口分配成功率
  - 端口分配耗时
  - 端口泄漏数量（已分配但环境不存在）
```

### 7.2 告警规则

| 指标 | 告警阈值 | 告警级别 |
|------|---------|---------|
| 端口池使用率 | > 80% | Warning |
| 端口池使用率 | > 95% | Critical |
| 端口分配失败率 | > 5% | Warning |
| 端口泄漏数量 | > 10 | Warning |

---

## 8. 实施计划

| 任务 | 工作量 | 依赖 |
|------|--------|------|
| 数据库表设计 | 0.5 天 | - |
| 端口池管理 | 1 天 | 数据库 |
| 端口分配/释放 | 1.5 天 | 端口池 |
| 端口回收机制 | 1 天 | 端口分配 |
| API 接口 | 1 天 | 端口管理 |
| 前端页面 | 1.5 天 | API |
| 测试 | 1 天 | 所有功能 |

**总工作量：** 7.5 天

---

**文档版本：** v1.0
**创建日期：** 2026-01-26
